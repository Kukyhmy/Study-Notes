----------------------
上下文切换
----------------------
	# 上下文切换
		* CPU从当前线程切换到其他线程，会保存当前线程的状态
		* 从其他线程，恢复到当前线程的时候回恢复状态

		* 线程每一次从 WAITING 切换到 RUNABLE 都是一次上下文的切换
	
	# 上下文切换次数过多，会导致性能问题
		* 这也是一些场景下，并发的效率还不如串行的效率高
	
	# 测试上下文切换次数和时长的工具
		* Lmbench3，Vmstat
	
	# 减少上下文的切换
		* 无锁并发编程
			* 多线程导致锁竞争，会带来上下文切换
			* 可以对数据进行hash分段，不同线程处理不同的数据段，避免锁竞争
		
		* CAS算法
			* 原子更新操作，避免枷锁

		* 协程
			* 单线程，调度N个任务(Java好像没原生的)
		
----------------------
死锁
----------------------
	# 死锁
		* 我中有你，你中有我
	
	# 避免
		* 避免一个线程同时获取多个锁
		* 避免一个线程同时在锁内占用多个资源，尽量保证一个锁只占据一个资源
		* 尝试使用定时锁，通过超时机制来自动的释放锁
		* 对于数据库来说，加锁和解锁，必须保证在同一个链接中，否则可能出现解锁失败
	
----------------------
资源限制的问题
----------------------
	# 资源限制
		* 并发编程的时候，受限于硬件/软件资源的限制
		
		* 带宽只有2Mb/s，启动100个线程执行下载，也不会变成 200Mb/s
		
		* 硬件带来的限制: 带宽,硬盘IO,CPU处理速度
		* 软件带来的限制: socket连接数
	
	# 资源受限导致的问题
		* 并发编程的目的在于并行执行，提高效率
		* 受限于资源，导致并行变成串行，而且额外添加了很多上下文切换的损耗，导致了性能不如串行
	
	# 解决
		* 硬件限制，可以集群，通过hash，把不同的资源分配给不同的节点处理
		* 软件限制，使用连接池，长连接代替短连接等方式
	
	# 调优
		* 在资源被限制的情况下，可以通过调节不同的参数，来达到最优效果
	
