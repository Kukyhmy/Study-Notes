--------------------
底层实现
--------------------
	# Java中所使用的并发机制依赖于JVM实现和CPU的指令

--------------------
volatile
--------------------
	# volatile
		* 多处理下，保证变量的“可见性”
		* 一个线程进行修改，另一个线程进行读取的时候，可以读取到修改后的值
		* 算轻量级的锁，比 synchronized 使用成本低，它没有线程上下文的切换和调度
	
	# 实现
		* 如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。
		* 但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。
		* 所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，
			* 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，
			* 当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，
			* 当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
		

		* 通俗理解，一个核对 volatile 数据修改，会通知其他核：“数据被我修改了，你们重新读”，其他核在对这个数据进行操作的时候就会重新读
	

--------------------
synchronized
--------------------
	# JAVASE1.6为了减少锁带来的消耗，引入了“偏向锁”，“轻量级锁”
	# 锁的4种状态
		* 无锁
		* 偏向锁
		* 轻量级锁
		* 重量级锁
		
		* 这几个状态会随着竞争逐渐升级，锁可以升级，但不能降级。目的是为了保证获取和释放锁的效率

	# 偏向锁
		* 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
		* 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。
		
		* 如果测试成功，表示线程已经获得了锁。
		* 如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：
			* 如果没有设置，则使用CAS竞争锁；
			* 如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

		
		* 通俗理解
			* 判断对象头的线程ID是不是自己，如果是，就获取锁了，不需要CAS加锁

			* ID不是自己，则看一下“偏向锁”标识是否设置成了1，没设置的话，就用CAS竞争锁
			* 已经设置了，就把通过CAS把偏向锁指定自己
		

		* 偏向锁释放，采用“等到竞争出现才释放”的机制，有其他线程来竞争的时候，持有偏向锁的线程才会释放锁
		
		* Java6/7，默认开起，会在程序启动后的几秒钟后才被激活，可以通过jvm参数来关闭延迟
		* 如果确定程序所有锁通常情况下都是竞争状态，也可以通过jvm参数“关闭偏向锁”，默认进入轻量级锁
	
	# 轻量级锁
		* 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。
		* 然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。
			* 如果成功，当前线程获得锁，
			* 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

		* 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，
			* 如果成功，则表示没有竞争发生。
			* 如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
	

	# 优缺点对比
		偏向锁
			* 加/解锁不需要额外的消耗，跟执行“非同步”方法相比，仅仅存在纳秒级别的差距
			* 如果线程之间存在竞争，会带来额外的锁撤销消耗
			* 适用于只有一个线程访同步块的场景

		轻量级锁
			* 竞争的线程不会阻塞，提高了程序的响应速度
			* 如果始终得不到锁竞争的线程，会一直自旋消耗CPU
			* 追求响应时间，同步块执行速度非常快

		重量级锁
			* 线程竞争不会使用自旋，不会消耗CPU
			* 线程阻塞，响应时间慢
			* 追求吞吐量，同步块执行时间较长
		


