------------------------------
零拷贝						  |
------------------------------
	# 非零拷贝的SocketIO步骤
		1. read 执行, 导致用户态到内核态发生第一次变化, DMA引擎从磁盘读取(复制)文件到内核缓冲区

		2. 把内核缓冲区的数据, 拷贝到用户缓冲区, 内核态到用户态的上下文切换

		3. 执行 write 的时候, 把用户缓冲区的数据拷贝到 Socket 缓冲区, 用户态到内核态的切换

		4. 数据异步的从 Socket 缓冲区使用 DMA 引擎拷贝到网络协议引擎 , 仍然是内核状态, 不需要切换

		5. write 方法返回, 再次从内核状态切换到用户态
	

	

	# mmap 优化
		* mmap 通过内存映射, 把文件映射到内核缓冲区, 用户空间可以共享内核空间的数据
		* 在网络传输的时候, 可以减少拷贝次数
		
		* 只需要把内核缓冲区的数据拷贝的 Socket 缓冲区, 减少了一次内存的拷贝
		* 但是没减少上下文的切换

		* MappedByteBuffer 就是 mmap
	
	# sendFile
		* inux 2.1 版本 提供了 sendFile 函数
		* 数据不经过用户态, 直接从内核缓冲区进入到 Socket Buffer
		* 同时, 由于和用户态完全无关, 就减少了一次上下文切换

		* 只需要2次拷贝
			1. 使用DMA引擎把文件从磁盘拷贝到内核缓冲区
			2. 从内核缓冲区把数据拷贝到网络协议栈

	

		*  FileChannel 的 transferTo 和 transferFrom 方法,即对应 Linux 的 sendFile
	
	
	# 总结
		* mmap 和 sendFile 的区别
			* mmap 适合小数据量读写, sendFile 适合大文件传输
			* mmap 需要 4 次上下文切换, 3 次数据拷贝, sendFile 需要 3 次上下文切换, 最少 2 次数据拷贝
			* sendFile 可以利用 DMA 方式, 减少 CPU 拷贝, mmap 则不能(必须从内核拷贝到 Socket 缓冲区)


		* 需要优化网络传输的性能, 或者文件读写的速度, 尽量使用零拷贝
		* 不仅能较少复制拷贝次数, 还能较少上下文切换, 缓存行污染
		


