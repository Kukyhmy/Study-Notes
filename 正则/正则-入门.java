----------------
入门			|
----------------
	* 参考学习(贼TM好入门的正则教程,鸣谢作者)
		http://deerchao.net/tutorials/regex/regex.htm

	* 老男孩python教程第18天 
	
--------------------
元字符				|
--------------------
	\b
		* 代表着词的开头或结尾,也就是词的分界处
		* 通常词是由空格,标点符号或者换行来分隔
		* 但是\b并不匹配这些单词分隔字符中的任何一个,它只匹配一个位置
		* 特殊字符的一个边界

	\d
		* 匹配一个数字

	\s
		* 任意的空白符,包括空格,制表符(Tab),换行符,中文全角空格

	\w
		* 匹配字母或数字或下划线或汉字

	.
		* 除了换行符以外的任意字符

	*
		* 代表数量
		* 前边的内容可以连续重复使用任意次,可以是0此

	+
		* 代表数量
		* 前边的内容可以连续重复使用任意次,起码是1此


	?
		* 代表数量
		* 重复零次或一次

		
	^
		* 匹配字符串开始

	$
		* 匹配字符串结束

	(
		* 

	)
		* 

--------------------
单个重复			|
--------------------
	*
		* 前边的内容可以连续重复使用任意次,可以是0此

	+
		* 前边的内容可以连续重复使用任意次,起码是1此

	?
		* 前边的内容可以重复零次或一次

	{n}
		* 重复n次

	{n,}
		* 重复n到无限次

	{n,m}
		* 重复n-m次

--------------------
转义				|
--------------------
	* 如果查找元字符本身的话,比如 ., 或者 * ,就出现了问题,没办法指定它们,因为它们会被解释成别的意思
    * 这时就得使用\来取消这些字符的特殊意义
    * 使用 \. 和 \* 当然，要查找\本身,你也得用 \\
    * demo
        deerchao\.net    匹配deerchao.net
        C:\\Windows    匹配C:\Windows

------------------------
字符类					|
------------------------
	* 想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u)
	* 只需要在方括号里列出它们就行了
		* [aeiou]	匹配任何一个英文元音字母
		* [.?!]匹配标点符号(.或?或!)
	
	* [] 还可以取消元字符的特殊意义(在[]里面的元字符,只是普通字符)
		[w,*] 可以匹配到 'wdwqdq*' 字符串中的 w 和 *

		* - \ ^ 例外,他们在[]里面还是具备特殊的功能
		* 如果需要转义,仍然需要添加 \ 来进行转义	
			[\\,\-,\^]



------------------------
分支条件				|
------------------------
	* 正则表达式里的分枝条件指的是有几种规则,如果满足其中任意一种规则都应该当成匹配
	* 具体方法是用 | 把不同的规则分隔开
	* 匹配分枝条件时,将会从左到右地测试每个条件,如果满足了某个分枝的话,就不会去再管其它的条件了

------------------------
分组					|
------------------------
	* 可以用小括号来指定子表达式(也叫做分组)
	* 可以指定这个子表达式的重复次数了,也可以对子表达式进行其它一些操作

------------------------
反义					|
------------------------
	* 需要查找不属于某个能简单定义的字符类的字符
	* 想查找除了数字以外,其它任意字符都行的情况,这时需要用到反义
		
		\W			
			* 任意不是字母,数字,下划线,汉字的字符
		\S			
			* 匹配任意不是空白符的字符
		\D			
			* 匹配任意非数字的字符
		\B			
			* 匹配不是单词开头或结束的位置
		[^x]		
			* 匹配除了x以外的任意字符
		[^aeiou]	
			* 匹配除了aeiou这几个字母以外的任意字符

	
	\S+			
		* 匹配不包含空白符的字符串
	<a[^>]+>	
		* 匹配用尖括号括起来的以a开头的字符串
		* [^>]+,匹配了所有的 <a + 任意非>的字符,最后以 > 结尾
	
------------------------
后向引用				|
------------------------
	* 使用小括号指定一个子表达式后,匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理
		(表达式)
		* 默认情况下,每个分组会自动拥有一个组号,规则是:从左向右,以分组的左括号为标志,第一个出现的分组的组号为1,第二个为2,以此类推
		* 分组0对应整个正则表达式
		* 实际上组号分配过程是要从左向右扫描两遍的
			第一遍只给未命名组分配(123...)
			第二遍只给命名组分配(456...)(因此所有命名组的组号都大于未命名的组号)
		* 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权

	* 定义组名称
		(?<组名称>表达式)
	
	* 不会被捕获到某个组里面,也不会拥有组号
		(?:表达式)
	
	* 注释
		(?#注释内容)

	* demo
		\b(\w+)\b\s+\1\b
	


------------------------
零宽断言				|
------------------------
	* 查找在某些内容(但并不包括这些内容)之前或之后的东西
	* 也就是说像\b,^,$那样用于指定一个位置,这个位置应该满足一定的条件(即断言),因此它们也被称为零宽断言

	* 零宽度正预测先行断言
		(?=正则)

		\b\w+(?=ing\b)						匹配以ing结尾的单词的'前面部分'(除了ing以外的部分)
		'm singing while you're dancing.	匹配 sing和danc。

	* 零宽度正回顾后发断言
		(?<=正则)

		(?<=\bre)\w+\b						匹配以re开头的单词的'后半部分'(除了re以外的部分)
		reading a book						它匹配 ading

------------------------
负向零宽断言			|
------------------------
	* 只是想要确保某个字符没有出现,但并不想去匹配它时	

	\b\w*q[^u]\w*\b
		* 匹配包含后面不是字母u的字母q的单词
		* 如果q出现在单词的结尾的话,像Iraq,Benq,这个表达式就会出错
		* 这是因为[^u]总要匹配一个字符,所以如果q是单词的最后一个字符的话,后面的[^u]将会匹配q后面的单词分隔符(可能是空格,或者是句号或其它的什么)
		* 后面的\w*\b将会匹配下一个单词,于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting
		* 负向零宽断言能解决这样的问题,因为它只匹配一个位置,并不消费任何字符

	* 断言此位置的后面不能匹配表达式exp(零宽度负预测先行断言)
		(?!exp)
	
	* 断言此位置的前面不能匹配表达式exp(零宽度负回顾后发断言)
		(?<!exp)
	

	* demo
		(?<=<(\w+)>).*(?=<\/\1>)			匹配不包含属性的简单HTML标签内里的内容

		* 请详细分析表达式(?<=<(\w+)>).*(?=<\/\1>),这个表达式最能表现零宽断言的真正用途
	
	* 懵懵的

------------------------
注释					|
------------------------
	* 小括号的另一种用途是通过语法(?#comment)来包含注释
		2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。
	* 要包含注释的话,最好是启用"忽略模式里的空白符"选项,这样在编写表达式时能任意的添加空格,Tab,换行,而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉
	* 我们可以前面的一个表达式写成这样
      (?<=    # 断言要匹配的文本的前缀
      <(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
      )       # 前缀结束
      .*      # 匹配任意文本
      (?=     # 断言要匹配的文本的后缀
      <\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
      )       # 后缀结束
	
------------------------
贪婪与懒惰				|
------------------------
	* 正则表达式中包含能接受重复的限定符时,通常的行为是(在使整个表达式能得到匹配的前提下)匹配尽可能多的字符
	* 贪婪匹配
		a.*b
			* 它将会匹配最长的以a开始,以b结束的字符串
			* 如果用它来搜索aabab的话,它会匹配整个字符串 aabab,这被称为贪婪匹配
	
	* 懒惰匹配
		* 有时,我们更需要懒惰匹配,也就是匹配尽可能少的字符,只要在表达式后面加上一个问号?
			a.*?b
			* 它将会匹配最长的以a开始,以b结束的字符串
			* 如果用它来搜索aabab的话,它会匹配 aab(第一到第三个字符)和 ab(第四到第五个字符)

		.*? 就意味着匹配任意数量的重复,但是在能使整个匹配成功的前提下使用最少的重复

	* 懒惰限定符
		
		*?		重复任意次,但尽可能少重复
		+?		重复1次或更多次,但尽可能少重复
		??		重复0次或1次,但尽可能少重复
		{n,m}?	重复n到m次,但尽可能少重复
		{n,}?	重复n次以上,但尽可能少重复

------------------------
平衡组/递归匹配			|
------------------------
	* 
		
