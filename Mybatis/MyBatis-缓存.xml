――――――――――――――――――――――――――――――――――――
1,MyBatis查询缓存					|
――――――――――――――――――――――――――――――――――――
	* MyBatis提供查询缓存,用于减轻数据库压力.提升性能
	* 它提供一级缓存,二级缓存
		* 其实就跟Hibernate一个德行



――――――――――――――――――――――――――――――――――――
1,MyBatis一级缓存					|
――――――――――――――――――――――――――――――――――――
	* 其实就是SqlSession的缓存(SqlSession 级别的缓存)
		在操作数据库的时候,需要构造SqlSession对象
		在对象中有一个数据结构 (HashMap) 用于存储缓存数据
		不同的SqlSession之间的缓存数据区域是'互不影响的'

	* 二级缓存是 mapper 级别的缓存,多个SqlSession之间可以'共享数据'
		多个SqlSession去操作同一个Mapper的Sql语句,多个SqlSession去操作数据库
		得到数据回存在二级缓存区域,二级缓存是跨SqlSession的
	
	如果缓存中有数据,就不用从数据库中获取,大大提高了系统的性能.

	一级缓存工作原理
			第一次根据id查询数据的时候,就把查询到的数据存入缓存
		当查询出的数据,在系统中执行了修改,删除的时候,执行commit
		当第二根据相同id查询的时候,直接从缓存区中取出数据

			如果SqlSession执行了commit操作(执行插入,删除,更新),会清空SqlSession中的一级缓存
		这样做的目的是,为了让缓存中永远存储的就是最新的信息,避免'脏读'.

	
	在正式开发时候,是把MyBatis,和Spring进行整合开发!事务控制是在 Service 中!
	一个Service中,可能会包含多个mapper方法的操作!

	service(){
		//开始执行时,开启事务.创建SqlSession对象
			//第一次调用mapper.getUser(1);
			//第二次调用mapper.getUser(1);
			* 其实这俩方法都是,用的同一个SqlSesion,一级缓存中的数据还在.
		//方法结束,SqlSession关闭
	}


――――――――――――――――――――――――――――――――――――
1,MyBatis二级缓存					|
――――――――――――――――――――――――――――――――――――
	* MyBatis的二级缓存是默认不开启的,需要手动开启.(这特么跟Hibernate也是一个德行... ... )
	* 跟一级缓存差不多,区别就是.二级缓存的范围更大.比一级缓存更大.多个SqlSession可以共享同一个二级缓存区域
	
	* 每个mapper的都有自己的缓存区域,不能混淆!
		* 通俗的理解就是,每个namespace都有一个自己的二级缓存区域
		* 如果两个mapper的namepace相同.那么他们的二级缓存都是同一个
		* 二级缓存内部还是 HashMap
	
	二级缓存的配置
		1,在SqlMapConfig.xml中开启二级缓存
			<settings>
				<!-- 二级缓存 -->
				<setting name="cacheEnabled" value="true"/>
			</settings>
			* 对在此配置文件下的所有cache进行全局性开/关配置
		2,在mapper.xml中设置缓存
			<cache/>
				属性
				flushInterval
					* 属性时间隔,可以被设置为任意的正整数,它们代表一个合理的毫秒形式时间段
					  默认情况是不设置的,也就是没有刷新时间隔,缓存仅仅调用语句时刷新
				readOnly
					* 只读属性,可以被设置为 true or false,只读的缓存会给所有调用者返回缓存对象的相同实例.因此这些对象不能被修改,这提供了很重要的性能优势
					   可读写的缓存会返回缓存对象的拷贝(通过序列化),这会慢一些,但是安全.默认为 false
				size
					* 引用数目,可以设置为任意正整数,要记住你缓存的对象数目和你运行环境的可用资源数目.默认为1024.说白了就是要根据实际的配置来定制.别搞内存溢出了
				type
					* 指定二级缓存的,实现类类型,MyBatis默认使用:PreoetualCache
					* 要和eache整合,那么这里就需要配置ecache实现了Cache接口的实现类
			* 那么这个mapper,里面执行的SQL语句就会存储到缓存
		3,POJO类要实现Serziable...接口(好像写错了)
			* 序列号的目的是为了反序列化.说白了,这个二级缓存可以'存储到本地硬盘'
			* 还是跟Hibernate一个德行,存储介质不一定在内存.硬盘,网络都有,远程服务器都可以

		['注意']
			一个SqlSession在关闭的时候(执行close()),才会把数据写入到二级缓存.
			如果没有关闭SqlSesion,它是不会往二级缓存写入数据的.千万注意!

			如果SqlSession执行了update,等语句,也会清空二级缓存

		禁用二级缓存
			* 不是什么数据都适合放在二级缓存的,比如敏感数据.财务数据等.都不能放置在二级缓存
			<select id="" resultMap="" useCache="false"..>

			* select 的 useCache标签可以控制是否存入二级缓存
		刷新二级缓存
			* 在mapper的同一个namespace中,如果有其他的update,insert,delete操作数据后,需要刷新缓存.如果不执行刷新缓存会出现脏读
			* 设置statement配置中的flushCache="true"属性,默认情况下为true即刷新缓存,如果改为 false ,则不会刷新.使用缓存时,如果手动修改数据表中的查询数据回出现脏读
			
			<insert id=""....flushCache="true">
			* 一般情况下,别设置这个.避免脏读

	
	使用第三方的缓存框架
		* ehcache,是一个分布式的缓存框架
		* 分布式缓存
			* 系统为了提高并发性能,一般都需要对系统进行分布式部署.一般常用的集群部署方式!
			* 如果不使用分布式缓存的话,那么缓存数据都在各个服务器单独存储!所有,弄个服务器.专门用来存储缓存!
			  redis,memached,ehcache都是属于分布式缓存框架
		* MyBatis无法实现分布式缓存,需要和其他的分布式缓存框架进行整合
		* MyBatis,做缓存不专业,但是要跟它玩儿的缓存,都得实现它指定的接口,起就是规范嘛
		整合方法
			MyBatis,提供了一个cache接口,如果我们要实现自己的缓存逻辑,那我们实现这个接口去开发就OK
				* org.apache.ibatis.cache.Cache.class
			MyBatis,要和ecache整合,那么他们的整合包中.就提提供了一个实现类
		1,加入ecache的jar包
			* MyBatis下面就有,一个是ecache自己的,一个是整合的,俩都一起加进去
		2,整合包下有俩类
			* EhcacheCache
			* LogginEhcache
			* 随便哪个都是
		3,在type标签中,粘贴进去实现类的全限定名.那么整合就OK了
			* <cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
		4,加入ehcache配置文件
			* 怎么配置的...百度,其实我也不知道.哈哈哈哈哈
			* 最大内存,对象总数.. ...什么什么的!
		
		重点就是知道这个cache接口
	

	应用场景
		对于访问多的查询请求,且对用户查询结果实时性要求不高.此时可以采用mybatis二级缓存技术降低数据库访问量.提高访问速度.
			* 耗时较高的统计分析,SQL,电话账单查询等SQL