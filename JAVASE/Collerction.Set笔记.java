											ArrayList al = new ArrayList();
								Collection 接口的所有方法 ―― 能应用到 List 以及 Set 的所有子类中
al.add(x);//添加一个x元素到al容器里面.
al.addAll(x);//将x容器里面的所有元素都添加到al容器中.
al.clear();//清空al容器里面的所有.
al.contains(x);//查询al容器里面是否有x元素.
al.containsAll(x);//查询al容器里面是否包含x容器中的所有元素.
al.equals(x);//比较al是不是与x对象相等.
al.hashCode();//获得al容器的哈希码值.
al.isEmpty();//判断al是否为空容器.
al.iterator();//获得al容器的迭代器。用于对al容器里面的元素进行迭代.
al.remove(x);//从容器al中删除x这个元素.
al.removeAll(x);//从容器al中删除x容器中所有的相同元素.――去交集
al.retainAll(x);//al容器里面只保留与x容器里面相同的元素.――取交集
al.size();//得到al容器的长度.
al.toArray();//把al集合变数组
al.toArray();//
----------------------------------------------------------------------
											Set 接口
												常见的子类 ―― HashSet TreeSet
	Set 集合和 List 集合刚好相反。 Set 元素是无序的（存入和取出的顺序不一定是一致的），元素不可以重复。
	Set 集合的功能和 Collection 的功能！'是一致！'。
	Set 集合的取出只有一种方法――迭代器
Set 子类 -------------------------------------------------------------------------

Set >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> HashSet
HashSet 底层数据结构是哈希表数据结构！
		在哈希表结构中判断元素是否相等。首先对比的是哈希值，如果哈希值相同。那么还会再比较元素是否相同。（equals）。
HashSet 是如何保证元素的唯一性呢？
		是通过元素的两个方法。hashCode 和 equals 来完成的。如果元素的hashCode值相同。才会判断equals是否为true！
		如果元素的hashCode值不同。那么不会调用equals。
'注意'  === 对于判断元素是否存在以及删除，添加等操作。依赖的方法是――元素的hashCode和equals方法！


Set >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TreeSet
TreeSet 可以对 Set 集合中的元素进行排序！ Set 你不是没顺序吗？老子给你指定个顺序排！
	那么存入 TreeSet 的对象。必须要先声明。你的元素排序规则。也就是你的元素要继承 Comparable 抽象类。覆写它的 compareTo 方法，来实现该元素的比较方法！
	排序的时候，当主要条件相同时。一定要判断一下次要条件！
	二叉树数据结构，又称为红黑树。
底层数据结构是 二叉树。保证元素唯一性的依据是。 Comparable 中的 compareTo 方法返回值 0；跟哈希值没关系！
TreeSet 排序的第一种方法：让元素自身具备比较性。让元素实现 Comparable ，覆盖'compareTo '(这种方式也称为元素的自然顺序，或者叫做默认顺序)
TreeSet 排序的第二种方法：当元素自身不具备比较性时。或者具备的比较性，不是所需要的。这时就需要让集合自身具备比较性。
		在集合初始化时，就已经有了比较方式。
当两种排序都存在时，以比较器为主。
定义一个类，实现 Comparator 接口。覆盖 'compare' 方法!然后把该对象作为形参传递给Set的容器的构造函数

