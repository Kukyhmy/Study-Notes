关于JAVA 多线程
	'进程：'
是一个正在执行中的程序。
	'线程：'
每一个进程执行都有一个执行的顺序。该顺序就是一个执行路径。或者叫一个控制单元。
线程就是进程中一个独立的控制单元。线程控制着线程的执行。一个进程中至少有一个线程。
	JAVA 虚拟机启动的时候会有一个进程。java.exe，该进程中至少有一个线程再负责JAVA程序的执行。而且这个线程运行的代码存在于main方法中。
该线程称之为――主线程。
【扩展】
	其实更细节说明JVM。JVM启动不只一个线程，还有负责垃圾回收机制的线程。
	【被创建】 ―― start() ―― 【运行】 ―― sleep(time) ―― 【冻结/休眠】
------------------ "创建线程的第一种方法"
1,定义类。继承 Thread
2,覆写run方法。
	目的是：将自定义的代码存储在run方法中。调用run方法。
3,调用线程的start();方法。
	3.1 启动线程。
	3.2 调用run方法。
------------------ "创建线程的第二种方法"
1,定义类.实现 Runnable 接口。
2,覆写 Runnable 接口中的run方法。
	|--将线程要运行的代码存放在run方法中。
3,通过 Thread 建立线程对象。
4,将 Runnable 接口的子类对象作为实际参数传递给 Thread 类的构造函数。
	|--为什么要将  Runnable 接口的子类对象传递给 Thread 的构造函数。因为，自定义的run方法所属的对象是 Runnable 接口子类对象。
所以要让线程去指定，指定对象的run。就必须明确该run方法所属的对象。
5,调用 Thread 类的 start(); 方法开启线程并调用 Runnable 接口子类的 run 方法。
------------------
'上述两种方式的区别：'
	实现方式好处在于避免了JAVA单继承的局限性。在定义线程时建议使用实现方式，也是最常用的！
继承 Thread ：线程代码存放在 Thread 子类run方法中。
实现 Runnable : 线程代码存放在接口的子类的run方法中。
Thread  类用于描述线程。
	该类就定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法！
也就是说 Thread 类中的run方法是用于存储线程要运行的代码。
线程都有自己默认的名称：
	Thread-0 该编号从0开始。
--------------------------------------'部分操作线程的方法'
currentThread();//获取当前线程对象。(Static)。返回的就是执行这个线程的对象。
getName();//获取线程的名称
this.getName();//获取的是默认的线程名称，是由系统定义的！(this)当前对象
setName();//设置线程的名称。或者在创建线程的时候直接通过构造函数传递名字。super();
Thread.sleep(long);//当线程执行到这句话的时候，会休眠指定的时间.1000毫秒=1秒
	|--而且，这个会有异常。且不能抛。只能自己 try进行处理！
getPriority();//返回线程的优先级
	|--默认的优先级是5！
setPriority();//更新线程优先级。
	|--只能传入   1-10  三个类型的数字。否则会报错。线程优先级仅仅表示线程获取时间片的几率高。但是要在次数比较多。或者多次运行的时候。才能看到比较好的效果。
'【多线程非常注意的问题】'
当一个线程已经 start();时如果再对它进行 start();的操作。那么会抛出。'无效线程异常'
	当多条语句在操作同一个线程共享数据时。一个线程对多条语句只执行了一部分还没有执行完毕。
另一个线程参与进来执行。导致共享数据的错误。
 解决办法：
	|--对多条共享操作共享数据的语句，只能让一个线程都执行完。在执行过程过。其他线程不可以参与执行。
JAVA对于多线程的安全问题。提供了专业的解决方式――同步代码块
如何去判断哪些语句需要被同步――'哪些语句在操作多线程的共享数据'
synchronized(对象)
{
	需要被同步的代码
}
	对象如同锁。持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权。也进不去。因为没有获取锁，
1,同步的前提――必须要有两个或者两个以上的线程才需要同步。
2,必须是多个线程同时使用同一个锁。
好处――解决了多线程的安全问题
弊端――会消耗更多的资源，因为每个线程都要判断锁。

如果同步函数被静态修饰后。那么它的锁不是 this 。静态方法中也不可以定义 this 。
静态进内存时候。内存中没有本类对象。但是一定有该类对应的字节码文件对象。
该对象的类型是 Class 
静态的同步方法使用的锁是该方法所在类的字节码文件对象也就是：类名.class 
――――懒汉式 饿汉式――――
死锁―― 
	同步里面嵌套同步  重点掌握
------------------------------------------------
线程间通讯：
	其实就是多个线程在操作同一个资源，但是操作的动作不同。
――――――――――――――――――――――――――――――――――――――――――――――――――――――
	"等待唤醒机制"
锁.wait();//让该监视器的这个线程处于等待状态。在内存中处于 内存池。
锁.notify();//
锁.notifyAll();//唤醒线程池里面该锁的所有线程，
	|--以上方法都使用在同步中。因为要对持有监视器（锁）的线程操作。
所以都要使用在同步中，因为只有同步才有具有锁！
他们之所以全部定义在 Object 中。因为这些方法在操作同步中线程时。都必须要标识他们所操作线程持有的锁！
只有同一个锁上的被等待线程可以被同一个锁上notifly();唤醒。不可以对不同锁中的线程进行唤醒。
'等待和唤醒必须是同一把锁'
也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法定义在 Object 中。
--------------------------------------------------
对于多个生产者和消费者。
为什么要定义 while 判断标记。
原因：让被唤醒的线程再一次判断标记

为什么定义notifyAll();
因为需要唤醒对方线程。因为只用notify，容易出现只唤醒本方线程的情况导致程序中的所有线程都等待。
--------------------------------------------------JDK 1.5新特性
Lock

