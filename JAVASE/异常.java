异常，就是程序在运行时出现的不正常的情况。
	异常的由来：问题也是现实中一个具体的事物，也可以通过JAVA的类的形式进行描述，并封装成对象。
	其实就是JAVA对不正常情况进行描述后的对象提现 ―― 这，就是异常。
对于问题的划分。分为两种，
一种是严重的问题。JAVA通过 Error 类进行描述。
	对于 Error 一般不编写针对性的代码。对其进行处理.
一种是非严重问题。通过 Exception 进行描述。
	对于 Exception 可以使用针对性的处理方式来对其进行处理。   （重点讲）

	无论 Error 还是 Exception 都有共性内容！
比如：不正常信息，引发原因等
Throwable
	|	Error
	|	Exception
异常的处理（代码提现）：
	try
	{
		需要被检测的代码;
	}
	catch (异常类，变量)
	{
		处理异常的代码（处理方式）；
	}
	finally
	{
		一定会执行的语句；
	}
对捕获到的异常对象进行常见方法操作。
getMessage();//获取异常的信息
printStackTrace();//异常信息，名称，出现的位置。其实JVM的默认异常处理机制。就是这个 printStackTrace（）；打印异常在堆栈中的跟踪信息

---------
throws Exception//在功能上通过 throws 的关键字声明了该功能有可能会出现问题！

 ―― '多异常处理'
 1，声明异常时，建议声明更为具体的异常。这样处理的可以更具体。
 2，对方声明几个异常。就对应有几个 catch 块。不要定义多余的 catch 块，
	如果多个 catch 块中的异常，出现继承关系。父类 catch 块放最下。
建议在进行 catch 处理时。 catch 一定要定义具体处理方法。不要只是简单的打印出问题简述。
―― '自定义异常'
	因为项目中会出现特有的问题。而这些问题并未被JAVA所描述封装对象。
	所以呢，对于这些特有的问题。可以按照JAVA的对问题的封装思想，把特有问题。进行自定义异常封装。
当在函数内部出现了 throw 抛出了异常对象。那么就必须要给出对应的处理动作！
要么在内部 try..catch 处理！要么在函数上声明。让调用者处理。
一般情况，在函数内出现异常。函数上需要声明。
打印的结果中只有异常的名称。只有异常的信息。因为自定义异常，并未定义所属信息！
如何定义异常信息？
因为父类已经把异常信息的操作都完成了！
所以子类只要在构造时。把异常信息传递给父类。通过 super();
那么就可以直接通过  getMessage 方法获取自定义的异常。
自定义异常。必须是自定义类继承 Exception 。
	为什么要继承 Exception
因为：异常体系有一个特点，因为异常类和异常对象。都需要被抛出。他们都具备可抛性。
这个可抛性是 Throwable 这个体系中的独有特点。只有这个体系中的类。和对象才可以被 throws 和 throw 操作！
-----------------------------------------------------------
throws 
	使用在函数上
	后面跟的异常类，可以跟多个。用逗号隔开
throw
	使用在函数内
	后面跟的是异常对象。
-----------------------------------------------------------
	Exception 中有一个特殊的子类异常。。。叫做： RuntimeException 运行异常。
	如果在函数内抛出该异常。函数上可以不用声明。编译一样通过！如果在函数上声明了该异常。调用者，可以不用进行处理。
	编译一样通过！
	之所以不用在函数声明，是因为不需要让调用者处理。当该异常发生，希望程序停止。因为在运行时。出现了
	无法继续运算的情况。希望程序停止后对代码进行修正。

	自定义异常时：如果该异常的发生无法在继续进行运算的话。就让自定义的异常继承 RuntimeException。

	对于异常分两种。
		一：编译时被检测的异常
		二：编译时不被检测的异常（运行时异常 RuntimeException 以及它的子类 ）
finally 代码块：
	定义一定执行的代码，通常用于关闭资源。某些代码一定要执行，就直接放里面！
	----------------------------------------
异常在子父类中的体现：
1，	子类在覆盖父类时。如果父类的方法抛出异常，那么子类的覆盖方法。只能抛出父类的异常或者该异常的子类。
2，如果父类方法抛出多个异常，那么子类在覆盖方法时。只能抛出父类异常的子集。
3，如果父类或者接口的方法中没有异常抛出。那么子类在覆盖方法时，也不可以抛出异常。
	如果子类方法，发生了异常。就必须要进行 try 处理。绝对不能抛。
总结――――――――――――
异常：
	异常就是对问题的描述，讲问题进行对象的封装。
异常体系
	Throwable
		|--Error
		|--Exception
			|--RuntimeException
异常体系特点：
	异常体系中的所有类以及建立的对象都具备可抛性。
	也就是说可以被 throw 和 throws 关键字操作。只有异常体系具备这个特点。
throw 和 throws 的特点
throw 定义在函数上，用于抛出异常对象。
throws 定义在函数上，用于抛出异常类，可以抛出多个，用逗号隔开。

当函数内有 throws 抛出异常对象。并未进行try处理。必要要在函数上声明，都会编译失败。
注意， RuntimeException 除外。也就是说，函数内如果抛出的是 RuntimeException  异常。函数上可以不用声明。

如果函数声明了异常。调用者需要进行处理。处理方法可抛可try。

异常有两种：
	1，编译时被检测异常
		该异常在编译时，如果没有处理（没有抛也没有try），那么编译失败。
		该异常被标识，代表这可以被处理。
	2，运行时异常（编译时不检测）
		在编译时不需要处理，编译器不检查。
		该异常的发生，建议不处理，让程序停止。需要对代码进行修正。
异常处理的语句：
try
{
	需要被检测的代码	
}
catch ()
{
	处理异常的代码
}
finally
{
	一定会执行的代码
}
有三种结合格式：
	try
	{
		
	}
	catch ()
	{
	}
	------------------
	try
	{
		
	}
	finally
	{
	}
	------------------
	try
	{
		
	}
	catch ()
	{
	}
	finally
	{
	}
	注意： finally 中定义的通常是关闭资源代码。因为资源必须释放！
		finally '只有一种情况不会执行 ，当执行到 System.exit(0); 的时候' finally 执行不到！
自定义异常：
	定义类集成 Exception 或者 RuntimeException
	1，是为了让该自定义类具备可抛性。
	2，是为了让该类具备操作异常的共性方法。

	当要定义自定义异常信息时，可以使用父类已经定义好的功能。
	class MyException extends Exception
	{
		MyException(String msg)
		{
			super(msg);
		}
	}

自定义异常是按照JAVA的面向对象思想讲程序中出现的特有问题，进行封装。

异常的好处：
	1，将问题进行封装。
	2，将正常流程代码和问题处理代码分离。方便于阅读。

异常的处理原则
	1，处理方式有两种：try和throws。
	2,调用到抛出异常的功能时，抛出几个，就处理几个。
		一个try对应多个catch
	3，如果多个catch，父类的往下放。放到最下面。
	4，catch内需要定义针对性的处理方式。不要简单的定义简单的输出语句，或者不写！
		当捕获到的异常，本功能处理不了时。可以继续在catch抛出。
		try
		{
			throw new AException();
		}
		catch (AException e)
		{
			throw e;
		}
		如果该异常处理不了。但并不属于该功能出现的异常。可以将异常转换后再抛出和该功能相关的异常。
		或者异常可以处理。但需要异常产生后产生的和本功能相关的问题提供出去。
		让调用者知道，并处理，也可以讲捕获异常
		处理后转换新的异常抛出。
		try
		{
			throw new AException();
		}
		catch (AException e)
		{
			throw new BException();
		}
异常的注意事项：
	1，在子父类覆盖时
		1.1，子类抛出的异常，必须是父类异常的子类或者子集。
		1.2，如果父类或者接口。没有异常抛出时。只能try不能抛。
	2，在函数中
		如果函数中抛出了异常。没有进行try catch 处理。那么谁调用必须要进行处理或者抛出！
		如果函数中抛出了异常。并自己进行处理。那么谁调用的时候也不用处理或者抛出！
		如果函数抛出了异常。自己进行了处理，但是没有处理到自己抛出去的异常。那么调用者也需要进行处理或者抛出。

