内部类的好处就是。内部类访问外部类成员的时候不需要创建外部类的对象。可以直接访问！
------内部类的定义规则
	当描述事物的时候，事物内部还有事物。因为内部事物在使用外部事物中的内容。
	例如	人体，心脏	(心脏有自己的方法，和属性。那么它就可以作为一个内部类使用)
-----------------内部类的访问规则
1,内部类可以直接访问外部类中的成员。包括私有化成员.
	之所以可以直接访问外部类中的成员。因为内部类中持有了一个外部类中的引用 ―― 外部类名.this.变量/方法;
2,外部类访问内部类成员必须要建立其对象才能进行访问。而且遵循类的访问规则。
	Outer.Inner in = new Outer().new Inner();//通过创建外部对象。来访问内部类，并创建其对象。
	外部类.内部类     外部类对象  内部类对象//访问内部类必须要有外部类的对象。
	'当内部类被私有化'
	上面的格式便不能进行访问了！需要通过其他的方法。例如通过外部类提，供访问内部类的方法。
	内部类访问自己本身的成员变量还是用 this.访问外部类的成员要用 -- 外部类名.this.变量名字;
	'当内部类是静态的'被 static 修饰.
	那么，内部类就只能直接访问外部类中的 static 成员。出现了访问局限。
	在其他的外部类中，访问 static 内部类的非静态成员
	new Outer.Inner().method();
	在其他的外部类中，访问 static 内部类的静态成员
	Outer.Inner.method();
	'注意，当内部类中的定义了静态成员的时候。该内部类必须是静态的'
	'当外部类中的静态方法访问内部类的时候，内部类也必须是静态的。'
3,'内部类被定义在外部类成员位置上的时候'，才可以被成员修饰符所修饰。 public private protected default 
  例如，内部类被定义在了。成员方法中(局部内部类)。的时候。是不能被成员修饰符所修饰的。而且，这个内部类的所有成员。都不能是静态的！
  可以直接访问外部类中的成员。因为还持有外部类中的引用,但是不可以直接访问它所在的局部中的变量。只能访问被 final 修饰的局部变量。(较新版本的JDK好像可以访问没有被 final 修饰的局部变量)
---------------匿名内部类
1,匿名内部类，其实就是内部类的简写格式.
2,'定义匿名内部类的前提'
	|--内部类必须是继承一个类，或者实现接口。
	new 父类/接口(){覆写方法}//这就是一个匿名内部类的对象
	new 父类/接口(){覆写方法}.方法/变量//匿名内部类访问成员变量或者方法。
---------------例
new Fu()//Fu 可以是一个这个匿名内部类的父类或者接口。如果该匿名内部类的构造函数有参数，那么参数就写在这个()括号里面！
	{
		void show()//内部类覆写父类的方法
		{
			System.out.println("show"+x);
		}
		//还可以继续定义子类的内容。
	}.show();//在.以前这一大堆代码其实就是一个对象！那么后面的.show();其实就是在调用它。
---------------这是一个，匿名子类对象。只是有点胖！也可以理解为，带内容的对象！
				后面可以调用代码块中的所有方法。或者变量。因为它就是一个对象。
				甚至还可以用父类引用去接收它 Fu f = 这串代码！那么这个对象，就被 f 指向了！就有名字了。也就不是匿名内部类。
				但是这个f因为是多态产生的。只能'调用覆写掉的父类的方法'。
好处：简化书写
弊端：只能调用父类覆写的方法。而且，只能调用一次。如果还要调用。那么还需要再次创建匿名内部类。
	  代码阅读性比较差
匿名内部类中定义的方法最好不要超过三个。
	 
