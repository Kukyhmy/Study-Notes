-----------------------
MySQL-事务				|
-----------------------
	# 讲事务这东西,都是拿银行转账来说事儿.
	# 事务跟存储引擎相关.有些引擎是不支持事务的
	# 参考
		https://mp.weixin.qq.com/s/XwC9n2Ik_DrfY-ERd99wqA
		https://www.imooc.com/article/17290

-----------------------
MySQL-CMD操作事务		|
-----------------------
	# 开启事务方法1
		BEGIN;
			
		update...
		delete...
		insert...

		COMMIT;
		ROLLBACK;
	
	# 开启事务方法2
		START TRANSACTION;
			* 开启了之后,就会把操作记录到事务日志
			* 还有一种方式设置.
				set autocommit=1;
				* 该方式,直接针对'当前连接'进行设置,以后的每次增删改操作,默认都是需要手动提交
				* 值也可以是:ON	 也是代表开启

		update...
		delete...
		insert...

		COMMIT;	
		ROLLBACK;

		* 本质上跟 BEGIN 其实是一样的, 但是 START TRANSACTION 后面可以跟一些其他的指令
			READ ONLY
				* 只读事务, 不能执行修改等操作
			
			READ WRITE
				* 读写事务, 即可读也可写(默认)
			
			WITH CONSISTENT SNAPSHOT
				* 启动一致性读
		
		* 如果存在多个指令的话, 可以使用逗号分隔


-----------------------
MySQL-事务回滚点		|
-----------------------
	# 其实我理解就是传说中的保存点.
	# 在某一个成功的操作完成之后,后续的操作有可能成功.有可能失败.
	# 在当前的位置,设置一个保存点,让后面的失败操作,返回到该位置
	# 语法
		savepint [回滚点名字];					创建回滚点
		rolback [回滚点名字];					回滚到指定的回滚点
		RELEASE SAVEPOINT [回滚点名字];			删除指定的回滚点
	# 往往是在事务操作比较多的时候,会用到
	# 操作步骤
		1,开启事务
			... 逻辑操作
			... 设置回滚点1
			... 设置回滚点2
			...
		2,回滚到指定的点
			... 继续逻辑操作
		3,提交/commit
			...
	
	# 事务一旦回滚,就会清空事务日志.设置了点之后,就仅仅清空点之后的事务日志


-----------------------
自动事务				|
-----------------------
	# MySql中默认都是自动的事务处理,用户的每个操作.都会自己开启,提交事务
	# 系统通过: autocommit 变量俩进行控制
	# show variables like 'autocommit';
		* ON	:表示是自动事务
		* OFF	:表示非自动事务
	# 关闭自动提交
		set autocommit = off;
		* 值为0也可以,因为0代表 false
	# 关闭之后,每次操作都需要执行commit命令
	# 通常都会使用自动事务,当需要使用到事务的时候,我们都是采取临时的事务
	# 该操作,仅仅是对当前连接/线程有效
	# 如果需要彻底修改,那么需要去修改配置文件

-----------------------
事务的隐式提交			|
-----------------------
	# 事务除了手动的调用 commit 以外, 在其他的一些情况下会手动的提交
	
	# 定义或修改数据库对象的数据定义语言(DDL)
		* 使用CREATE, ALTER, DROP等语句去修改这些所谓的数据库对象(数据库, 表, 视图, 存储过程等等这些东西)时, 就会自动提交前面的事务
	
	# 隐式使用或修改mysql数据库中的表
		* 使用ALTER USER, CREATE USER, DROP USER, GRANT, RENAME USER, REVOKE, SET PASSWORD等语句时也会隐式的提交前边语句所属于的事务
	
	# 事务控制或关于锁定的语句
		* 一个事务还没提交或者回滚时就又使用START TRANSACTION或者BEGIN语句开启了另一个事务时, 会隐式的提交上一个事务
		* 使用LOCK TABLES, UNLOCK TABLES等关于锁定的语句也会隐式的提交前边语句所属的事务
	
	# 加载数据的语句
		* 使用LOAD DATA语句来批量往数据库中导入数据时, 也会隐式的提交前边语句所属的事务
	
	# MySQL复制的一些语句
		* 使用ANALYZE TABLE, CACHE INDEX, CHECK TABLE, FLUSH, LOAD INDEX INTO CACHE, OPTIMIZE TABLE, REPAIR TABLE, RESET等语句也会隐式的提交前边语句所属的事务
	

-----------------------
事务特性				|
-----------------------
	事务的四大特效:
	# A-Atomic		原子性
		* 一组事务,要么全部提交成功,要么全部失败
		*  Undo log 保证, Undo Log 会保存每次变更之前的记录, 从而在发生错误时进行回滚

	# C-Con...		一致性
		* 事务操作的前后,数据表中的数据.没有变化

	# I-Isol..		隔离性
		* 事务的操作是相互隔离,不受影响的
		* 隔离性由 MVCC 和 Lock 保证

	# D-D...		持久性
		* 事务一旦提交,就必须要保存到数据库,永久的改变数据表
		* 持久性由 Redo Log 保证,每次真正修改数据之前, 都会将记录写到 Redo Log 中, 只有 Redo Log 写入成功, 才会真正的写入到 B+ 树中
		* 如果提交之前断电, 就可以通过 Redo Log 恢复记录

-----------------------
锁机制					|
-----------------------
	# 因为事务的'隔离性质',所以在多线程的时候,MYSQL会有一个锁机制来保证数据的安全
	# INNODB引擎默认的锁机制是:行级锁
	# 但是如果在事务操作的过程中,没有使用到索引(就是说WHERE条件没有使用到主键).那么系统会自动全表检索数据,那么就会自动升级为表锁
	# 行锁:只有当前行被锁定,别的线程不能进行操作
		* 一个线程开启了事务,进行了事务操作之后(使用到了索引,就会单单锁定该行记录)
		* 另外的线程对该条记录进行增/删/该.会被线程阻塞.直到当前事务提交或者回滚

	# 表锁:只有当前表被锁定,别的线程不能进行操作
		* 一个线程开启了事务,进行了事务操作之后(如果操作没有使用到索引,直接锁整张表),
		* 另外的线程对该表进行增/删/改.会被线程阻塞.直到当前事务提交或者回滚
	
-----------------------
事务的隔离级别			|
-----------------------
	# 并发读问题(严重性由低到高)
		* 脏写			:因为另一个事务的回滚, 覆盖了当前事务的提交
			* 脏写这个问题太严重了, 不论是哪种隔离级别, 都不允许脏写的情况发生
			* InnoDB使用锁来保证不会有脏写情况的发生, 也就是在第一个事务更新了某条记录后, 就会给这条记录加锁, 另一个事务再次更新时就需要等待第一个事务提交了, 把锁释放之后才可以继续更新
		
		* 脏读			:读到另一个事务未提交的数据, 主要体现是在修改数据
		* 不可重复读	:两次读取不一致
		* 幻读(虚读)	:按照某个相同条件多次读取记录时, 后读取时读到了之前没有读到的记录, 主要体现是其他事务插入了数据
	
		
	# 四大隔离级别
		* 是用来防止上面三种读问题
		* 4个等级的事物隔离级别,在相同的输入,执行相同的工作,根据不同的隔离级别,可以导致不同的结果。不同的事务隔离级别能够解决数据并发问题的能力是不同的.
		1,Serializable(串行化)(坚决不用)
			* 不会出现任何问题,因为它对同一数据的访问是串行的,并非并发访问的！
			* 性能最差(能处理任何问题)
		2,Repeatable read(可重复读取)(MYSQL默认)
			* 防止脏读和不可重复读,不能处理幻读问题
			* 性能比 Serializable 好
		3,Read Committed(读已提交数据)(Oracle默认)
			* 防止脏读和不可重复读,没有处理不可重复读,也没处理幻读
			* 性能别 Serializable 好
		4,Read Uncommitted 读未提交数据(坚决不用)
			* 可以出现任何事务并发问题,没有处理任何问题.隔离级别最烂
			* 性能最好
	
	#　查看数据库的隔离级别
		select @@tx_isolation   
		* MYSQL的默认隔离级别(一般没有必要去修改)
		+-----------------+
		| @@tx_isolation  |
		+-----------------+
		| REPEATABLE-READ |
		+-----------------+

	# 修改数据库的隔离级别
		settransaction isolationlevel [四个隔离级别选一个]

	# JDBC设置隔离级别
		Connection conn
		conn.setTransactionlsolation(int leve);
		参数可选值如下
		Connection.TRANSACTION_READ_UNCOMMITTED
		Connection.TRANSACTION_READ_COMMITTED
		... ... 静态变量,字段参阅API

-----------------------
JDBC操作事务			|
-----------------------
	try{
		conn.setAutoCommit(false);//开启事物
		... 
		...
		...
		conn.commit();//try语句的最后提交事务
	}catch(Exception e){
		conn.rollback();//回滚事务
	}

------------------------
MVCC原理				|
------------------------
	# 一个非常易懂的介绍
		https://juejin.im/book/5bffcbc9f265da614b11b731/section/5c923cfcf265da60f00ecaa9
	
	# MVCC(Multi-Version Concurrency Control)
		* 多版本并发控制

	# InnoDB存储引擎的表来说, 它的聚簇索引记录中都包含两个必要的隐藏列
		trx_id
			* 每次一个事务对某条聚簇索引记录进行改动时, 都会把该事务的事务id赋值给trx_id隐藏列

		roll_pointer
			* 每次对某条聚簇索引记录进行改动时, 都会把旧的版本写入到undo日志中
			* 这个隐藏列就相当于一个指针, 可以通过它来找到该记录修改前的信息
	
	
		* 每次对记录进行改动, 都会将旧值记录到一条undo日志, 每条undo日志也都有一个 roll_pointer 属性
		* 这些undo日志都会连起来, 串成一个链表, 这个链表称之为版本链, 版本链的头节点就是当前记录最新的值
		* 每个版本中还包含生成该版本时对应的事务id



	# ReadView
		* 使用READ UNCOMMITTED隔离级别的事务来说, 由于可以读到未提交事务修改过的记录, 所以直接读取记录的最新版本就好了
		* 使用SERIALIZABLE隔离级别的事务来说, 使用加锁的方式来访问记录
		
		* 使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说, 都必须保证读到已经提交了的事务修改过的记录
		* 也就是说假如另一个事务已经修改了记录但是尚未提交, 是不能直接读取最新版本的记录的
		* 问题就是:需要判断一下版本链中的哪个版本是当前事务可见的
		
		* InnoDB的提出了一个ReadView的概念
		* 这个ReadView中主要包含4个比较重要的内容:
			m_ids
				* 在生成ReadView时当前系统中活跃的读写事务的事务id列表

			min_trx_id
				* 表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id
				* 也就是m_ids中的最小值

			max_trx_id
				* 表示生成ReadView时系统中应该分配给下一个事务的id值
				* max_trx_id并不是m_ids中的最大值, 事务id是递增分配的

				* 比方说现在有id为1, 2, 3这三个事务, 之后id为3的事务提交了
				* 那么一个新的读事务在生成ReadView时, m_ids就包括1和2, min_trx_id的值就是1, max_trx_id的值就是4

			creator_trx_id
				* 表示生成该ReadView的事务的事务id
				* 只有第一次在对表中的记录做改动时(执行INSERT, DELETE, UPDATE这些语句时)才会为事务分配事务id
				* 否则在一个只读事务中的事务id值都默认为0
			
		* 有了ReadView, 在访问某条记录时, 只需要按照下边的步骤判断记录的某个版本是否可见
			1. 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同
				* 意味着当前事务在访问它自己修改过的记录, 所以该版本可以被当前事务访问
			
			2. 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值
				* 表明生成该版本的事务在当前事务生成ReadView前已经提交, 所以该版本可以被当前事务访问
			
			3. 如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值
				* 表明生成该版本的事务在当前事务生成ReadView后才开启, 所以该版本不可以被当前事务访问
			
			4. 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间
				* 那就需要判断一下trx_id属性值是不是在m_ids列表中
				* 如果在, 说明创建ReadView时生成该版本的事务还是活跃的, 该版本不可以被访问
				* 如果不在, 说明创建ReadView时生成该版本的事务已经被提交, 该版本可以被访问
		


			* 如果某个版本的数据对当前事务不可见的话, 那就顺着版本链找到下一个版本的数据
			* 继续按照上边的步骤判断可见性, 依此类推, 直到版本链中的最后一个版本
			* 如果最后一个版本也不可见的话, 那么就意味着该条记录对该事务完全不可见, 查询结果就不包含该记录
		


	# READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同
		READ COMMITTED  每次读取数据前都生成一个ReadView
		REPEATABLE READ 在第一次读取数据时生成一个ReadView, 之后的查询就不会重复生成了
		
	# insert undo在事务提交之后就可以被释放掉
	
	# 关于purge
		* insert undo在事务提交之后就可以被释放掉了, 而update undo由于还需要支持MVCC, 不能立即删除掉
		* DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除, 而是执行一个所谓的delete mark操作
		* 相当于只是对记录打上了一个删除标志位, 这主要就是为MVCC服务的

		* 随着系统的运行, 在确定系统中包含最早产生的那个ReadView的事务不会再访问某些update undo日志以及被打了删除标记的记录后
		* 有一个后台运行的purge线程会把它们真正的删除掉
	
	# 所谓的MVCC只是在我们进行普通的SEELCT查询时才生效
		

-------------------------------------------------
Read Committed, 是否能彻底解决幻读的问题		 |
-------------------------------------------------
	# MYSQL 的 Read Committed, 其实是可以解决幻读的问题
		+---------------------------+-------------------------------------------+
		|  SESSION1					|  SESSION2									|
		+-----------------------------------------------------------------------+
		|start transaction;			|	start transaction;						|
		+-----------------------------------------------------------------------+
		|select * from `user`;		|											|
		+-----------------------------------------------------------------------+
		|							|	insert into `user` values(2, 0, 0);		|
		+-----------------------------------------------------------------------+
		|							|	commit;									|
		+-----------------------------------------------------------------------+
		|select * from `user`;		|											|
		+-----------------------------------------------------------------------+
		|commit;					|											|
		+-----------------------------------------------------------------------+
		
		* SESSION1 先执行 select 发现读取不到数据
		* SESSION2 执行 insert 插入了记录
		* SESSION1 再次 select语句, 不能检索到session2的新插入的记录
		* 如果SESSION2 执行删除提交, 那么SESSION1 未提交之前还是可以读取到这条已经被删除的记录


	# MYSQL 的 Read Committed, 不一定可以彻底解决幻读的问题
		* 数据信息
			+----+---------+---------+
			| id | balance | version |
			+----+---------+---------+
			|  1 |       0 |       1 |
			|  2 |       0 |       1 |
			+----+---------+---------+
		
		* 检索
			+-------------------------------------------------------+-------------------------------------------+
			|SESSION1												|SESSION2									|
			+-------------------------------------------------------+-------------------------------------------+
			|start transaction;										|start transaction;							|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|														|insert into `user` values(3, 0, 2);		|
			+-------------------------------------------------------+-------------------------------------------+
			|														|commit;									|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|update `user` set `balance` = 1 where `version` = 2;	|											|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|commit;												|											|
			+-------------------------------------------------------+-------------------------------------------+
			
			* SESSION1 第一次检索, DB记录不存在
			* SESSION1 第二次检索, 检索不到SESSION2新插入的记录, 防止了幻读
				Empty set (0.00 sec)

			* 但是SESSION1 尝试去对 SESSION2 新插入的记录执行 UPDATE, 可以修改成功
			* 修改成功后, 再次执行 SELECT, 可以检索出SESSION2新插入的记录
				+----+---------+---------+
				| id | balance | version |
				+----+---------+---------+
				|  3 |       1 |       2 |
				+----+---------+---------+
			
			* 原因
				- 在REPEATABLE READ隔离级别下, T1第一次执行普通的SELECT语句时生成了一个ReadView, 之后T2向hero表中新插入了一条记录便提交了
				- ReadView并不能阻止T1执行UPDATE或者DELETE语句来对改动这个新插入的记录, 因为T2已经提交, 所以改动该记录并不会造成阻塞
				- 但是这样一来这条新记录的 trx_id 隐藏列就变成了T1的事务id, 之后T1中再使用普通的SELECT语句去查询这条记录时就可以看到这条记录了
				- 也就把这条记录返回给客户端了, 因为这个特殊现象的存在, 也可以认为InnoDB中的MVCC并不能完完全全的禁止幻读


---------------------------------------------------------
T1									T2
SELECT IN SHARE MODE `m`				
									DELETE FROM `m`
INSERT INTO `s`					
									DELETE FROM `s`