# Innodb行格式
## Innodb页
- 将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。
- 也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

## Innodb行格式
- 我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式
- 目前行格式有4种类型
  - Compact
  - Redundant
  - Dynamic
  - Compressed
- 指定行格式
```sql
mysql> CREATE TABLE  ... CHARSET=ascii ROW_FORMAT=COMPACT;
```

## Compact 行格式
```
| 记录的额外信息                      |   记录的真实数据
------------------------------------------------------------------
变长字段列表 | NULL值列表 | 记录头信息 | 列1的值 | 列2的值 | 列n的值
------------------------------------------------------------------
```

### 变长字段长度列表
- `VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，把拥有这些数据类型的列称为变长字段。
- 变长字段中存储多少字节的数据是不固定的，所以这些变长字段占用的存储空间分为两部分
  - 真正的数据内容
  - 占用的字节数

- 在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表， 
- 各变长字段数据占用的字节数按照列的顺序逆序存放。注意，逆序存放。
```
c1[varchar(10)]      c2[varchar(10) NOT NULL]     c3[CHAR(10)]     c4[VARCHAR(10)]
'aaaa'               'bbb'                        -                'd'
--------
c1, 4个字节
c2, 3个字节
c4, 1个字节
逆序存储在变长字段长度列表中就是就是  => 01 03 04  (存储是没有空格的，这里为了方便演示逆序，添加了空格)
```
- 变长列的内容占用的字节数比较多，可能就需要用2个字节来表示
- 至于是用1个还是2个字节，有一个计算公式
  - W：表示一个字符最多需要使用的字节数，utf8=3，gbk=2，ascii=1
  - M：这种类型表示能存储最多多少个字符，所以这个类型能表示的字符串最多占用的字节数就是 `M × W`。
  - L：实际占用存储的字节数量
```
if M × W <= 255 {
    使用1个字节存储
} else {
  if L <= 127 {
      使用1个字节存储
  } else {
      使用2个字节存储
  }
}
```
- 变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的
- 并不是所有记录都有这个**变长字段长度列表**部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

> InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？InnoDB使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。
对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

### NULL值列表
- 某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方
- 为了避免冗余存储，所以`Compact`把这些值为NULL的列统一管理起来，存储到NULL值列表中
- 处理过程
  1. 统计表中允许存储NULL的列有哪些。
  2. 如果表中没有允许存储 NULL 的列，则**NULL值列表**也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
     - 2进制位的值为1时，代表该列的值为NULL。 
     - 2进制位的值为0时，代表该列的值不为NULL。
  3. NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。
  
```
c1[varchar(10)]      c2[varchar(10) NOT NULL]     c3[CHAR(10)]     c4[VARCHAR(10)]
---------
其中，c1,c3,c4列都可以为null，
所以在NULL值列表中存储的3个比特位（逆序） => [0|0|0|0|0|c4|c3|c1]
```

### 记录头信息
- 记录头信息，它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思
```
预留位1          1	没有使用
预留位2	        1	没有使用
delete_mask	    1	标记该记录是否被删除
min_rec_mask	1	B+树的每层非叶子节点中的最小记录都会添加该标记
n_owned	        4	表示当前记录拥有的记录数
heap_no	        13	表示当前记录在记录堆的位置信息
record_type	    3	表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录
next_record	    16	表示下一条记录的相对位置
```

### 记录的真实数据
- 除了自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下
  - row_id(DB_ROW_ID)，非必须，6个字节，是行ID唯一标识一条记录
  - transaction_id(DB_TRX_ID)，必须，6字节，事务ID
  - roll_pointer(DB_ROLL_PTR)，必须，7字节，回滚指针
- row_id，可选的 优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键， 
- 如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键

#### CHAR(M)列的存储格式
- 采用的是ascii字符集，这个字符集是一个定长字符集，也就是说表示一个字符采用固定的一个字节，占用的字节数不会被加到变长字段长度列表，
- 采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如gbk表示一个字符要1～2个字节、utf8表示一个字符要1～3个字节等）的话，列的长度也会被存储到变长字段长度列表中  

- 变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)却没有这个要求
> 比方说对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。


## Redundant 行格式
```
| 记录的额外信息            |   记录的真实数据
------------------------------------------------------------------
字段长度偏移列表 |记录头信息 | 列1的值 | 列2的值 | 列n的值
------------------------------------------------------------------
```
### 字段长度偏移列表
- Redundant行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。
- 它是采用两个相邻数值的差值来计算各个列值的长度。

### 记录头信息
- 记录头信息占用6字节，48个二进制位，这些二进制位代表的意思如下：
```
预留位1	        1	没有使用
预留位2	        1	没有使用
delete_mask	    1	标记该记录是否被删除
min_rec_mask	1	B+树的每层非叶子节点中的最小记录都会添加该标记
n_owned	        4	表示当前记录拥有的记录数
heap_no	        13	表示当前记录在页面堆的位置信息
n_field	        10	表示记录中列的数量
1byte_offs_flag	1	标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的
next_record	    16	表示下一条记录的绝对位置
```
- 1byte_offs_flag的值是根据该条Redundant行格式记录的真实数据占用的总大小来判断的
  - 当记录的真实数据占用的字节数不大于127（十六进制0x7F，二进制01111111）时，每个列对应的偏移量占用1个字节。
  - 当记录的真实数据占用的字节数大于127，但不大于32767（十六进制0x7FFF，二进制0111111111111111）时，每个列对应的偏移量占用2个字节。
  - 真实数据大于32767，记录已经存放到了溢出页中，在本页中只保留前部分字节和20个字节的溢出页面地址，所以每个列使用2个字节来存储偏移量就够了。（字段长度偏移列表处只需要记录每个列在本页面中的偏移就好了）

### NULL值的处理
- Redundant行格式并没有NULL值列表，Redundant在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 
> 将列对应的偏移量值的第一个比特位作为是否为NULL的依据，该比特位也可以被称之为NULL比特位。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的NULL比特位是不是为1，如果为1，那么该列的值就是NULL，否则不是NULL。

- 对于值为NULL的列来说，该列的类型是否为定长类型决定了NULL值的实际存储方式
- 如果存储NULL值的字段是定长类型的，比方说CHAR(M)数据类型的，则NULL值也将占用记录的真实数据部分，并把该字段对应的数据使用0x00字节填充。
- 如果该存储NULL值的字段是变长数据类型的，则不在记录的真实数据处占用任何存储空间。

### CHAR(M)列的存储格式
- Redundant行格式中十分干脆，不管该列使用的字符集是啥，只要是使用CHAR(M)类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M的乘积。 
> 比方说使用utf8字符集的CHAR(10)类型的列占用的真实数据空间始终为30个字节，使用gbk字符集的CHAR(10)类型的列占用的真实数据空间始终为20个字节。
- 由此可以看出来，使用Redundant行格式的CHAR(M)类型的列是不会产生碎片的。

## 行溢出数据
### 一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！
- MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。 
- 这个65535个字节除了列本身的数据之外，还包括一些其他的数据（storage overhead） 
- 比如说为了存储一个VARCHAR(M)类型的列，其实需要占用3部分存储空间：
  - 真实数据
  - 真实数据占用字节的长度
  - NULL值标识，如果该列有NOT NULL属性则可以没有这部分存储空间
  > VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节：
  > 
  > 如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识：

- 如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。
- 在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2）,也就是说最多能存储32766个字符
- utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。

### 记录太多产生溢出
- MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节
- 一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录

- 在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，

```
```

### 行溢出的临界点
- MySQL中规定一个页中至少存放两行记录
- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间
- 每个记录需要的额外信息是27字节。 
   - 2个字节用于存储真实数据的长度
   - 1个字节用于存储列是否是NULL值
   - 5个字节大小的头信息
   - 6个字节的row_id列
   - 6个字节的transaction_id列
   - 7个字节的roll_pointer列
> 假设一个列中存储的数据字节数为n，设计MySQL的大叔规定如果该列不发生溢出的现象，就需要满足这个式子：
> 132 + 2×(27 + n) < 16384

- 不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为溢出列。

## Dynamic和Compressed行格式
- MySQL版本是5.7，它的默认行格式就是Dynamic，这俩行格式和Compact行格式挺像
- 只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前部分字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址
```

```
- Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。
