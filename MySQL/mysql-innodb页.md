# innodb页
- 页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。
- InnoDB为了不同的目的而设计了许多种不同类型的页
    - 存放表空间头部信息的页
    - 存放Insert Buffer信息的页
    - 存放INODE信息的页
    - 存放undo日志信息的页
    - 存放记录页 - 索引（INDEX）页

# 数据页

```
File Header	        文件头部	        38字节	页的一些通用信息
Page Header	        页面头部	        56字节	数据页专有的一些信息
Infimum + Supremum	最小记录和最大记录	26字节	两个虚拟的行记录（数据记录）
User Records	    用户记录	        不确定	实际存储的行记录内容（数据记录）
Free Space	        空闲空间	        不确定	页中尚未使用的空间
Page Directory	    页面目录	        不确定	页中的某些记录的相对位置
File Trailer	    文件尾部	        8字节	校验页是否完整
```

- 存储的记录会按照指定的行格式存储到User Records部分
- 最开始没有User Records。新插入记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分
- Free Space全部被User Records占用完毕后，就表示这个页用完了，新插入记录就要创建新的页了

## 每条记录的记录头信息（Compact格式）
- 记录头信息，它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思
```
预留位1          1	没有使用
预留位2	        1	没有使用
delete_mask	    1	标记该记录是否被删除
    * 值为0的时候代表记录并没有被删除，为1的时候代表记录被删除掉了。
    * 立即从磁盘上移除的话，移除之后把其他的记录在磁盘上重新排列需要性能消耗
    * 所以打一个删除标记，所有被删除掉的记录都会组成一个所谓的垃圾链表
    * 在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
    * delete_mask位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段
    
min_rec_mask	1	B+树的每层非叶子节点中的最小记录都会添加该标记
    * B+树的每层非叶子节点中的最小记录都会添加该标记，
    * 只有在存储目录项(record_type=1的情况)记录，的页中的主键值最小的目录项记录的min_rec_mask值为1
    * 其他别的记录的min_rec_mask值都是0。
    
n_owned	        4	表示当前记录拥有的记录数
heap_no	        13	表示当前记录在记录堆的位置信息
record_type	    3	表示当前记录的类型
    * 0表示普通记录
    * 1表示B+树非叶子节点记录，只有主键值和页的编号两个列（也就是索引，它存储了页码编号，以及页码中的最小索引值）
    * 2表示最小记录
    * 3表示最大记录

next_record	    16	表示下一条记录的相对位置
    * 它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量
    * 比方说第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。
    * 这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。
    * 而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录） 
    
```

## 虚拟记录
- Innodb会自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。
- 这两个伪记录一个代表最小记录，一个代表最大记录，单纯存放在页的`Infimum + Supremum`部分
- 这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的
```
最小记录 = |记录头信息|infimum|  // 只有7个字节，后面加了个 0x00
最大记录 = |记录头信息|superman|
```
- 最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。


## Page Directory（页目录）
 - InnoDB对记录也制作了目录，他们的制作过程是这样的：
    1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
    2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
    3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到Page Directory，也就是页目录。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。
     
- 最小记录的n_owned值，也就是最小记录本身。
- 最大记录的n_owned值，包括最大记录本身还有我们自己插入的n条记录。

- 每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 1 条记录，
- 最大记录所在的分组拥有的记录条数只能在 1~8 条之间
- 剩下的分组中记录的条数范围只能在是 4~8 条之间。所以分组是按照下边的步骤进行的：
    - 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
    - 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
    - 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

### 在一个数据页中查找指定主键值的记录的过程分为两步：
1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的next_record属性遍历该槽所在的组中的各个记录。

## Page Header（页面头部）
- 专门针对数据页记录，存储记录的各种状态信息，这个部分占用固定的56个字节，专门存储各种状态信息，
```sql
PAGE_N_DIR_SLOTS	2字节	在页目录中的槽数量
PAGE_HEAP_TOP	    2字节	还未使用的空间最小地址，也就是说从该地址之后就是Free Space
PAGE_N_HEAP	        2字节	本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）
PAGE_FREE	        2字节	第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）
PAGE_GARBAGE	    2字节	已删除记录占用的字节数
PAGE_LAST_INSERT	2字节	最后插入记录的位置
PAGE_DIRECTION	    2字节	记录插入的方向
    * 假如新插入的一条记录的主键值比上一条记录的主键值大，那么这条记录的插入方向是右边，反之则是左边。
    * 用来表示最后一条记录插入方向的状态就是 PAGE_DIRECTION。

PAGE_N_DIRECTION	2字节	一个方向连续插入的记录数量
    * 假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。
    * 如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

PAGE_N_RECS	        2字节	该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）
PAGE_MAX_TRX_ID	    8字节	修改当前页的最大事务ID，该值仅在二级索引中定义
PAGE_LEVEL	        2字节	当前页在B+树中所处的层级
PAGE_INDEX_ID	    8字节	索引ID，表示当前页属于哪个索引
PAGE_BTR_SEG_LEAF	10字节	B+树叶子段的头部信息，仅在B+树的Root页定义
PAGE_BTR_SEG_TOP	10字节	B+树非叶子段的头部信息，仅在B+树的Root页定义
```

## File Header（文件头部）
- File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，
- 它描述了一些针对各种页都通用的一些信息
```sql
FIL_PAGE_SPACE_OR_CHKSUM	        4字节	页的校验和（checksum值）    
    * 当前页面的校验和（checksum），类似于Hash

FIL_PAGE_OFFSET	                    4字节	页号
    * 每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。

FIL_PAGE_PREV	                    4字节	上一个页的页号
FIL_PAGE_NEXT	                    4字节	下一个页的页号
    * 分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。
    * 并不是所有类型的页都有上一个和下一个页的属性

FIL_PAGE_LSN	                    8字节	页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）
FIL_PAGE_TYPE	                    2字节	该页的类型
    * 页的类型

FIL_PAGE_FILE_FLUSH_LSN	            8字节	仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值
FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID	4字节	页属于哪个表空间
```
### 页类型（FIL_PAGE_TYPE）
```
FIL_PAGE_TYPE_ALLOCATED	    0x0000	最新分配，还没使用
FIL_PAGE_UNDO_LOG	        0x0002	Undo日志页
FIL_PAGE_INODE	            0x0003	段信息节点
FIL_PAGE_IBUF_FREE_LIST	    0x0004	Insert Buffer空闲列表
FIL_PAGE_IBUF_BITMAP	    0x0005	Insert Buffer位图
FIL_PAGE_TYPE_SYS	        0x0006	系统页
FIL_PAGE_TYPE_TRX_SYS	    0x0007	事务系统数据
FIL_PAGE_TYPE_FSP_HDR	    0x0008	表空间头部信息
FIL_PAGE_TYPE_XDES	        0x0009	扩展描述页
FIL_PAGE_TYPE_BLOB	        0x000A	溢出页
FIL_PAGE_INDEX	            0x45BF	索引页，也就是我们所说的数据页
```

### File Trailer
- 用于检测一个页是否完整，这个部分由8个字节组成，可以分成2个小部分，
- 前4个字节代表页的校验和
> 这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）
> 这个部分也是为了校验页的完整性的，

