-----------------------
MySQL-优化				|
-----------------------
	# 针对于mysql.5.6
	# 5.6整体的性能要高于5.5
	# 优化的原则
		减少系统瓶颈,减少资源占用,增加系统的反映速度
	
	# 查看数据库的性能参数
		show status
		show status like '%value%'
	
	# 常用的参数
		slow_queries
			* 慢查询次数
			* show status like 'slow_queries';
		Com_(CURD)
			* 操作的次数
			* show status like '%com_select%';
		Uptime
			* 上线时间
			* show status like '%Uptime%';
-----------------------
MySQL-查询优化			|
-----------------------
	# 在mysql中使用 EXPLAIN 查看SQL执行计划.
		* EXPLAIN select * from tb_name;
		
		+----+-------------+-------+------+---------------+------+---------+------+------+-------+
		| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------+
		|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    6 | NULL  |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------+
		id				
			* 检索的唯一标识符,不用计较
		select_type		
			* 表示SELECT语句的类型,有如下几种值
				1,SIMPLE		//表示简单查询,其中不包含连接查询和子查询
				2,PRIMARY		//表示主查询,或者是最外面的查询语句
				3,UNION			//表示连接查询的第2个或者后面的查询语句
				... ...
		table
			* 检索的表
		
		type
			* '重点,非常的重要'
			* 表示,表的连接类型
			* 如下的连接类型,是'从优到次'
				1,system
					* 表示仅有一行,这是 const 类型的特例,平时不会出现.可以忽略不计
				2,const
					* 数据表最多只有一行匹配,因为只匹配一行,所以很快.
					* 常用于:primarykey和unique的查询,因为只有一条记录,所有很快.可以理解为最优化的检索
				
				3,eq_ref
					* mysql手册这样描述:'对于每个来自于前面的表的组合,从该表中读取一行,这可能是最好的连接类型,除了 const 类型,它用在一个索引的所有部分被联接使用,并且索引是UNIQUE或PRIMARYKEY'
					* eq_red可以用于使用=比较带索引的列
				
				4,ref
					* 查询条件索引既不是UNIQUE也不是PRIMARYKEY,
					* ref可用于=或者>操作符的带索引的列
				5,ref_or_null
					* 该联接类型如果ref,但是添加了mysql可以专门搜索包含null值的行,在解决子查询中经常使用该联接类型的优化
				
				# '上面五种情况都是很理想的索引使用情况,如果是下面的情况,那么就是优化点'

				6,index_merge
					* 该联接类型表示使用了索引并优化方法,在这种情况下,key列包含了使用的索引清单.key_len包含了使用的索引的最长的关键元素
				7,unique_subquery
				8,index_subquery
				9,range
				10,index
				11,ALL
					* 对于每个来自于先前表的行组合,进行完整的表扫描(性能最渣)
					* '只要是ALL,那就是肯定需要优化'
				

		possible_keys
			* 之处MYSQL能使用哪个索引在该表中找到行
			* 如果该列为 null,则表示没有使用索引,可以对该列创建索引来提高性能
		
		key
			* 显示MYSQL实际决定使用的健(索引),如果没有选择索引,键是null
			* 可以强制使用索引,或者忽略该索引
		
		key_len
			* 显示MYSQL决定使用健长度,如果是null,则长度为null
			* 注意:key_len,是确定了mysql将实际使用的索引长度
		
		ref
			* 显示使用哪个列或者常数与key一起从表中选择行
		
		rows
			* 显示MYSQL认为它执行检索的时候,必须检查的行数
		
		Extra
			* 该列包含MYSQL解决查询的详细信息
				Distinct:发现第一个匹配行后,停止为当前的行组合搜索更多的行
				...
			
		
		
-----------------------
MySQL-优化策略			|
-----------------------
	# 使用连接查询,代替子查询.效率较搞
	# 把字段很多的表,分为多个表
	# 增加中间表
		* 对于需要经常联合检索的表,可以建立中间表,提高检索效率

	# 增加冗余字段


-----------------------
MySQL-服务器的优化		|
-----------------------
	# 服务器的硬件直接决定了MYSQL数据库的性能
	# 需要从以下几个方面考虑
		1,配置大内存,提高MYSQL性能,内存IO比硬盘快很多.增大内存,扩充缓存.让数据在内存中停留更久
		2,高速磁盘.ssd
		3,合理分配磁盘IO,把IO分散到多个设备上.以减少资源的竞争.提高并行操作能力
		4,多核处理,MYSQL是多线程的数据库,多核处理可以提高同时执行N个线程的能力
	# MYSQL参数的优化
		* 'mysql的配置参数,都是在my.cnf文件的[mysqld]中'

		key_buffer_size 
			* 表示索引缓冲区大小,索引缓冲区所有的线程共享
			* 增加索引缓冲区,可以得到更好处理的索引(对所有读和写).
			* 当前这个值也不是越大越好,它的大小取决于内存的大小,如果这个值太大.会导致操作系统频繁换页,也会降低系统性能
		
		table_cache
			* 表示同时打开的表的个数,这个值越大,能够同时打开的表也就越多.
			* 这个值不是越大越好,表打开太多,会影响系统性能
		
		query_cache_size
			* 表示查询缓冲区大小,该参数需要和 query_cache_type 配合使用
			* 当 query_cache_type 的值是0的时候,所有的查询都不使用查询缓冲区.
			* 但是query_cache_type=0,并不会导致MYSQL使用query_cache_size所配置的缓冲区内存
			* 当 query_cache_type=1的时候。。。 。。。
		
	

		
		
