# 锁
## 事务并发的几个问题
### 读读
- 读取操作本身不会对记录有影响，并不会引起什么问题，所以允许这种情况的发生。

### 写写
- 在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的

- 锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的
- 当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构
    - 当没有的时候就会在内存中生成一个锁结构与之关联

#### 锁结构信息
- trx信息：代表这个锁结构是哪个事务生成的。
- is_waiting：代表当前事务是否在等待。
> 还有很多其他的属性，只是这两个比较重要

#### 假设，T1和T22个事务并发修改
- T1改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，（获取锁成功）
- T2也想对该记录做改动，那么先去看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后**也生成了一个锁结构与这条记录关联**，不过锁结构的is_waiting属性值为true，（获取锁失败）

- 事务T1提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，
- 发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的is_waiting属性设置为false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。

#### 总结锁的一些说法
- 不加锁，意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。
- 获取锁成功，或者加锁成功，意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting属性为false，也就是事务可以继续执行操作。
- 获取锁失败，或者加锁失败，或者没有获取到锁，意思就是在内存中生成了对应的锁结构，不过锁结构的is_waiting属性为true，也就是事务需要等待，不可以继续执行操作。


### 读-写/写-读
- 也就是一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。
- MySQL在REPEATABLE READ隔离级别实际上就已经解决了幻读问题。
- 解决脏读、不可重复读、幻读这些问题，其实有两种可选的解决方案：
    1. 方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。
    2. 方案二：读、写操作都采用加锁的方式。

- 采用MVCC方式的话，读-写操作彼此并不冲突，性能更高，
- 采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。一般情况下愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行

## 一致性读（Consistent Reads）
- 事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，有的地方也称之为快照读。 
- 所有普通的SELECT语句（plain SELECT）在READ COMMITTED、REPEATABLE READ隔离级别下都算是一致性读
- 一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动。

## 锁定读（Locking Reads）
### 共享锁
- Shared Locks，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。
```
SELECT ... LOCK IN SHARE MODE;
```

### 独占锁
- 也常称排他锁，英文名：Exclusive Locks，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。
```
SELECT ... FOR UPDATE;
```

### 兼容性
```
兼容性	X	    S
X	    不兼容	不兼容
S	    不兼容	兼容
```

## 锁定写
- DELETE，做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取一下这条记录的X锁，然后再执行delete mark操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读
- UPDATE，在对一条记录做UPDATE操作时分为三种情况：
    1. 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。
    2. 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。
    3. 如果修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。
- INSERT，一般情况下，新插入一条记录的操作并不加锁，InnoDB通过一种称之为隐式锁的机制来保护这条新插入的记录在本事务提交前不被别的事务访问

## 多粒度锁
### 行锁
- 上面说了
### 表锁
- 给表加的锁也可以分为共享锁（S锁）和独占锁（X锁）
- 如果一个事务给表加了S锁，那么：
    - 别的事务可以继续获得该表的S锁
    - 别的事务可以继续获得该表中的某些记录的S锁
    - 别的事务不可以继续获得该表的X锁
    - 别的事务不可以继续获得该表中的某些记录的X锁
    
- 给表加X锁：
    - 别的事务不可以继续获得该表的S锁
    - 别的事务不可以继续获得该表中的某些记录的S锁
    - 别的事务不可以继续获得该表的X锁
    - 别的事务不可以继续获得该表中的某些记录的X锁
    

### 意向锁
- 在尝试对表添加X锁的时候，怎么知道里面是否有记录添加了X/S锁？
- 在尝试对表添加S锁的时候，怎么知道里面是否有记录添加了X锁？

- 遍历所有记录，效率太低，于是设计了一个“意向锁”的东西

- 意向共享锁，英文名：Intention Shared Lock，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。
- 意向独占锁，英文名：Intention Exclusive Lock，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。

- IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。

### 兼容性
```
兼容性	X	    IX	    S	    IS
X	    不兼容	不兼容	不兼容	不兼容
IX	    不兼容	兼容	    不兼容	兼容
S	    不兼容	不兼容	兼容	    兼容
IS	    不兼容	兼容	    兼容	    兼容
```

## InnoDB存储引擎中的表锁
### 表级别的S锁、X锁
- 对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。
- 一般情况下也不会使用InnoDB存储引擎自己提供的表级别的S锁和X锁。
- InnoDB存储引擎提供的表级S锁或者X锁是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。可以手动获取一下.
    - LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁。
    - LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁。

### 表级别的IS锁、IX锁
- 对使用InnoDB存储引擎的表的某些记录加S锁之前，那就需要先在表级别加一个IS锁，
- 对使用InnoDB存储引擎的表的某些记录加X锁之前，那就需要先在表级别加一个IX锁。

- IS锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。

### 表级别的AUTO-INC锁
- 可以为表的某个列添加AUTO_INCREMENT属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值
- 系统实现这种自动给AUTO_INCREMENT修饰的列递增赋值的原理主要是两个：
    1. 采用AUTO-INC锁，也就是在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。
    2. 采用一个轻量级的锁，在为插入语句生成AUTO_INCREMENT修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的AUTO_INCREMENT列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。

## InnoDB中的行级锁
- 行锁，也称为记录锁，顾名思义就是在记录上加的锁。
- 花样很多，也就是把行锁分成了各种类型。换句话说即使对同一条记录加行锁，如果类型不同，起到的功效也是不同的

### Record Locks
- 记录锁就是这种类型，也就是仅仅把一条记录锁上，官方的类型名称为：LOCK_REC_NOT_GAP
- 有S锁和X锁之分

### Gap Locks
- MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决
- 使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，无法给这些幻影记录加上正经记录锁。

- InnoDB，提出了一种称之为Gap Locks的锁，官方的类型名称为：LOCK_GAP，可以简称为gap锁
```
+-----------------------------+--------+
|1   |3     |8 |15        |20 |superman|
|Java|Python|Go|Javascript|C++|        |
+-----------------------------+--------+
```
- 说明
    - 为id值为8的记录加了gap锁，意味着不允许别的事务在number值为8的记录前边的间隙插入新记录，其实就是number列的值(3, 8)这个区间的新记录是不允许立即插入的
    - 会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，number列的值在区间(3, 8)中的新记录才可以被插入
    
    - 为了实现阻止其他事务插入number值在(20, +∞)这个区间的新记录，我们可以给索引中的最后一条记录，也就是number值为20的那条记录所在页面的Supremum记录加上一个gap锁
    - Supremum记录，表示该页面中最大的记录。


  
- gap锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。
- 而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加Record Locks锁或者继续加gap锁


### Next-Key Locks
- 既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录,InnoDB的提出了一种称之为Next-Key Locks的锁
- 方的类型名称为：LOCK_ORDINARY，我们也可以简称为next-key锁
- next-key锁的本质就是一个Record Locks锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。

### Insert Intention Locks
- 一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁(next-key锁也包含gap锁)
- 如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交
  
- InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。
- InnoDB就把这种类型的锁命名为Insert Intention Locks，官方的类型名称为：LOCK_INSERT_INTENTION，也可以称为插入意向锁。

### 隐式锁
- 一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id这个牛逼的东东的存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。

## InnoDB锁的内存结构
