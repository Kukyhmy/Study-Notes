---------------------------
SQL编程						|
---------------------------

---------------------------
变量						|
---------------------------
	# 系统变量
		* 是系统定义好的变量,我们只需要去使用即可,大部分的时候,我们根本不用使用到
		* 是控制服务器的表现:autocommit.....等等
		* 查看系统变量:show variables like '变量名';
		* 修改系统变量:set [变量名] = [值];
		* 查看具体变量值还有一种方式
			SELECT @@变量名
			select @@version,@@xxx,@xxx...;
			* 系统变量前面是加俩@符号
			
	# 修改系统变量
		1,会话级别的修改,该次修改仅仅对当前线程/会话有效
			set [变量名] = [值];
			set @@变量名 = [值];
		2,全局级别的修改,对所有的线程/会话都有效,一次修改永久生效
			set global @@变量名 = [值];
			* 这种修改方式对于当前在线的其他用户无效,其他用户得重新登录才有效
		

	# 自定义变量
		* MYSQL中为了区分系统变量,规定用户自定义变量必须使用一个 @符号;
		* set @name = 'KevinBlandy';		//定义变量
		* select @name;						//获取变量
	
		* 在MYSQL中的 '=',会默认的当作比较符号来进行处理,MYSQL为了区分比较和赋值,所以专门定义了一个赋值符号:		:=
		* 颜文字,呵呵:冒号等于
			set @name := 'KevinBlandy';
			select @name;

		* MYSQL允许从数据表中获取数据,赋值给变量
			1,边赋值,边查看结果
				select [变量名] := (子查询);								//该返回值是单行单列
					select @name := (select name from user where id = 1);	
				select [变量名] := [列名] from [表名];
					select @name := name from user ;						//注意了,这个操作是把一列数据都给了该变量,其实这个变量一直在改变,最终值就是最后一个值
				* 得使用:=,如果直接使用等号会变成比较符号	
				
			2,仅仅赋值,不查看
				* 这种赋值会比较严格,要求赋值的结果仅仅只能是单行,不能是'多行',也就是仅仅一条记录,MYSQL没有数组这个概念
				set [变量名] := (子查询);														//要求返回单行单列
					set @name := (select name from user where id = 1);			
				select [字段1],[字段2]... from [表名] where [条件] into @变量1,@变量2...;		//可以返回多列,但是只能是一行.而且有多少个字段就必须要有多少个变量
					select name,age from user where id = 1 info @name,@age;
					* 注意的是结果
										
		* 所有自定义的变量都是会话级别,当前连接/用户有效.退了就没了;
		* 这种变量也可以理解为全局变量,如果不加@,那么就是局部变量,在函数中会有该情况

---------------------------
触发器						|
---------------------------
	# 触发器,几个要素
		1,事件
		2,处理代码
		3,处理时机

	# 事件
		update
		delete
		insert

	# 处理代码
		就是SQL语句

	# 处理时机
		before	事件执行前
		alfer	事件执行后
	
	# 创建

		delimiter $$					
		create trigger 名称 时机 事件 on 表名 for each row 
		begin
				执行代码;
		end $$
		delimiter ;

		* 注意啦,这里是begin和end代表编程中的{}
		* begin和end里面的每行内容都必须使用语句结束符
		* 但是矛盾来了,(;),CMD遇到分号后面就不执行了.所以我们需要临时修改语句结束符
		* 说白了就是,这CMD的结束符跟MYSQL的撞上了,本来MYSQL中不该结束的,这CMD强行给结束了,所以我们得定义一个新的,让CMD遇到新的才结束.那么SQL中使用';',号.CMD不会结束掉它!而MYSQL知道这一行结束了.
		* delimiter [自定义符号]			//后续代码只有碰到自定义符号才算是结束
		* 把临时修改,需要改正过来:delimiter ;
		* 在MYSQL客户端中也可以使用

	# 查询
		show create trigger 名称
	# 删除
		drop trigger 名称
		* 触发器不能修改,只能先删除再新增
	# 记录(高级)
		* 不管触发器是否触发,只要当某个操作准备执行.系统就会把当前要操作的记录的当前状态和即将执行之后的新的状态,给分别保留
		* 通俗,你'准备'要修改一个东西的时候.系统会把修改前的样子和修改后的样子保留下来.给触发器使用,也只能给触发器使用
		* old.字段				//获取旧记录的某个值
		* new.字段				//获取新记录的某个值(如果是自增长ID,那么就可以通过这个方式来获取到插入数据的主键值)
		* 那么在编写触发语句的时候,就可以使用旧的数据以及修改后的数据
		* 仅仅对更新有效,插入没旧的,删除没新的.

	# 注意
		* 触发器是针对表,不能针对行
		* 一张表只能拥有一个
		* 当一个表绑定了一个事件,就不能再绑定另一个事件,但是可以给不同的事件,绑定不同的触发器.也就是说一张表最多有6个触发器
		* 所有的触发器都会保存到一张表中:infomation_schema.triggers
		* 触发器,没有提供'中止事件'的操作,所以如果有必要.就要自己弄个错误的SQL语句,让它报错
		
---------------------------
代码执行结构－ if			|
---------------------------
	# 不多解释了
	# 在MYSQL中,只有 if 分支
	# 基本语法 
		if [条件判断] then 
			//满足要执行的SQL代码
		else
			//不满足条件要执行的代码
		end if;

---------------------------
代码执行结构－ while		|
---------------------------
	# 循环不解释了,计算机的世界其实都是在重复干活儿
	# 某个代码在指定条件下玩命循环
	# while (没有 for 循环)
	# 基本语法
		[循环名字]:while [条件] do
			//满足条件要执行循环代码
			//变更循环条件
		end while ;

	# 循环控制,在循环内部进行判断和控制
		* MYSQL中没有:continue 和 break,但是有替代品
			Iterate : 类似于 continue ,后面的代码不执行,循环重新来过
			leave	: 类似于 break	,	代表循环结束
		* 使用方式
			Iterate/leave [循环名字];
		* Demo
			[循环名字]:while [条件] do 
				//循环体
				//循环控制(条件)
				Iterate/leave [循环名字];
			end while;
		

	

