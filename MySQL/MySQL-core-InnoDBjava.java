--------------------------------
InnoDB							|
--------------------------------
	# InnoDB将数据划分为若干个页, 以页作为磁盘和内存之间交互的基本单位
		* InnoDB中页的大小一般为 16 KB
		* 也就是在一般情况下, 一次最少从磁盘中读取16KB的内容到内存中, 一次最少把内存中的16KB内容刷新到磁盘中

	# InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列
		*  row_id 是可选的, 在没有自定义主键以及非null的Unique键的情况下才会添加该列
	


--------------------------------
InnoDB行格式					|
--------------------------------	
	# 一般是以记录为单位来向表中插入数据的, 这些记录在磁盘上的存放方式也被称为行格式或者记录格式
	# InnoDB存储引擎到现在为止设计了4种不同类型的行格式
		Compact
		Redundant
		Dynamic
		Compressed

	# 指定/修改行格式的语法, 使用关键字:ROW_FORMAT
		CREATE TABLE 表名 ... ROW_FORMAT=行格式名称

		ALTER TABLE 表名 ROW_FORMAT=行格式名称

	# Compact
		+----------------------------------+-------------------------------+
		|		记录的额外信息			   |		记录的真实数据		   |
		+----------------------------------+-------+-------+-------+-------+
		|变长字段列表|NULL值列表|记录头信息|列1的值|列2的值|... ...|列n的值|
		+----------------------------------+-------+-------+-------+-------+
		
		# 变长字段列表
			* MySQL支持一些变长的数据类型, 比如VARCHAR(M), VARBINARY(M), 各种TEXT类型, 各种BLOB类型
			* 这些数据类型的列称为变长字段, 存储的数据大小不是固定的, 在存储这些数据的时候, 它们实际占用的大小, 也需要被存储起来

			* 在该格式中, 把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位
			* 从而形成一个变长字段长度列表, 各变长字段数据占用的字节数'按照列的顺序逆序存放'
			* 也就是说, 列中最后一个变长字段的占用长度数据, 存储在第一个
		
			
			* 使用多少个字节来表示变长字段的数据大小?是可以有公式进行计算的
				W		一个字符的最大体积(根据编码不同,可能有所不同)
				M		列数据类型,可以最多存储的数据大小
				L		数据实际占用的空间大小
				
				
				if (M * W <= 255){
					使用一个字节存储长度
				} else if(M * W > 255){
					if(L <= 127){
						使用一个字节存储长度
					}else if(L > 127){
						使用2个字节存储长度
					}
				}
			
			* 如果某个字段长度大于了16KB, 那么如果该记录在单个页面中无法存储时, InnoDB会把一部分数据存放到所谓的溢出页中
			* 变长字段长度列表处只存储留在本页面中的长度, 所以使用两个字节也可以存放下来
		
		
		# NULL值列表
			* 表中的某些列可能存储NULL值, 如果把这些NULL值都放到记录的真实数据中存储会很占地方, 所以Compact行格式把这些值为NULL的列统一管理起来, 存储到NULL值列表中

			* 首先统计表中允许存储NULL的列有哪些, NOT NULL 修饰的列都是不可以存储NULL值的, 所以在统计的时候不会把这些列算进去
			* 将每个允许存储NULL的列对应一个二进制位(Bit), 二进制位按照列的顺序逆序排列
				* 二进制位的值为1时, 代表该列的值为NULL
				* 二进制位的值为0时, 代表该列的值不为NULL

			* 如果表中没有允许存储 NULL 的列, 则 NULL值列表 也不存在了
		
				
					
				



			
				