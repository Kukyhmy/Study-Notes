# 事务
## 基本特性
### 四大属性
- 原子性（Atomicity）
- 隔离性（Isolation）
- 一致性（Consistency）
- 持久性（Durability）

### 事务状态
- 活动的（active）
- 部分提交的（partially committed）
- 失败的（failed）
- 中止的（aborted）
- 提交的（committed）

### 隐式提交
- 定义或修改数据库对象的数据定义语言（Data definition language，缩写为：DDL）。
- 隐式使用或修改mysql数据库中的表
- 事务控制或关于锁定的语句
- 加载数据的语句
- 关于MySQL复制的一些语句
- 其它的一些语句

## Redo日志
### 刷盘的问题
- Innodb使用页来管理数据，修改操作本质上都是修改页。在访问页的时候，需要先把页加载到内存的Buffer Pool中，修改完毕后刷到磁盘（持久性）。
- 提交事务后，已经在内存中修改完毕，但是还没来得及刷到磁盘，就断电了，那么就会导致内存中的数据丢失。
  
- 简单的处理方式： 事务提交完成之前把该事务所修改的所有页面都刷新到磁盘
    1. 刷新一个完整的数据页太浪费了，页是基本单位，16KB，如果只因为修改了1个字节，就要刷新16KB的数据到磁盘上显然是太浪费了。
    2. 随机IO刷起来比较慢，修改的页可能不相邻，需要随机IO进行修改

### Redo日志解决
- Redo日志就是记录了一些，哪些数据被修改了
- 事务提交的时候，只将该事务执行过程中产生的redo日志刷新到磁盘，就算系统宕机，重启后还是可以冲Redo日志中恢复
    1. redo日志占用的空间非常小
    2. redo日志是顺序写入磁盘的

### Redo日志格式
```
+------------------------------+
|type|space ID|page number|data|
+------------------------------+
type：该条redo日志的类型。
space ID：表空间ID。
page number：页号。
data：该条redo日志的具体内容。
```

### Redo日志刷盘时机
- log buffer空间不足时（log buffer的大小是有限的（通过系统变量innodb_log_buffer_size指定））
- 事务提交时
- 后台线程不停的刷刷刷（后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。）
- 正常关闭服务器时
- 做所谓的checkpoint时
- 其他的一些情况...

### Redo日志文件
- MySQL的数据目录（使用SHOW VARIABLES LIKE 'datadir'查看）下默认有两个名为`ib_logfile0`和`ib_logfile1的文件
- 默认情况下就是刷新到这两个磁盘文件中。如果对默认的redo日志文件不满意，可以通过下边几个启动参数来调节：
  - innodb_log_group_home_dir   指定了redo日志文件所在的目录，默认值就是当前的数据目录。
  - innodb_log_file_size 指定了每个redo日志文件的大小，在MySQL 5.7.21这个版本中的默认值为48MB，
  - innodb_log_files_in_group 指定redo日志文件的个数，默认值为2，最大值为100。

- redo日志写入日志文件组时，是从ib_logfile0开始写，如果ib_logfile0写满了，就接着ib_logfile1写，同理，ib_logfile1写满了就去写ib_logfile2，依此类推。如果写到最后一个文件该咋办？那就重新转到ib_logfile0继续写

## Undo日志
### 事务回滚的问题
- 事务执行一半，因为系统宕机，或者手动回滚。为了保证事务的原子性，需要把已经修改的数据还原成原来的样子。
- 这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。
- 回滚的本质
    - 插入了一条记录，回滚操作对应的就是把这条记录删除掉； 
    - 更新了一条记录，回滚操作对应的就是把该记录更新为旧值；
    - 删除了一条记录，回滚操作对应的自然就是把该记录再插进去；
    
### Undo日志
- 当对数据做改动的时候，`INSERT`, `UPDATE`, `DELETE`。都要把回滚所需的东西记下来，这些为了回滚而记录的这些东东称之为撤销日志，英文名为undo log
    - 插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
    - 删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。
    - 修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。

### Insert undo
- insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）
- 虽然真正的insert undo日志占用的存储空间被释放了，但是roll_pointer的值并不会被清除，roll_pointer属性占用7个字节，第一个比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时，就代表着它指向的undo日志类型为insert undo。

## 事务ID
- 如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id
    - 对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id，否则的话是不分配事务id的
    - 对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id，否则的话也是不分配事务id的（默认为0）。
- InnoDB记录行格式，会有一个隐藏列：trx_id，就是某个对这个聚簇索引记录做改动的语句所在的事务对应的事务id而已（此处的改动可以是INSERT、DELETE、UPDATE操作）

### 事务ID生成
- 事务id本质上就是一个数字，分配策略如下：
    - 服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id时，就会把该变量的值当作事务id分配给该事务，并且把该变量自增1。
    - 每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为5的页面中一个称之为Max Trx ID的属性处，这个属性占用8个字节的存储空间。
    - 当系统下一次重新启动时，会将上边提到的Max Trx ID属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于Max Trx ID属性值）。


