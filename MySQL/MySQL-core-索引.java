----------------------------
索引						|
----------------------------
	# 正确的创建合适的数据库索引, 是提升查询效率的基础

	# MySQL的存储和查找
		* MySql 将数据按照页来存储, 默认一页为 16kb, 一页里面可以有N多条数据记录
		* 在查询时, 不会只加载某一条数据, 而是将这个数据所在的页都加载到 pageCache 中, 这个其实和 OS 的就近访问原理类似
		* 在一个页里面查找记录的两种情况
			1. 以主键为搜索条件
				* 中使用二分法快速定位到对应的槽, 然后再遍历该槽对应分组中的记录即可快速找到指定的记录

			2. 以其他列作为搜索条件
				* 遍历

		* 大部分情况下表中存放的记录都是非常多的, 需要好多的数据页来存储这些记录
		* 在很多页中查找记录的话可以分为两个步骤
			1. 定位到记录所在的页
			2. 从所在的页内中查找相应的记录(上面的方法)
	
	# 优点
		* 天生排序
		* 快速查找
	
	# 缺点
		* 占用空间
		* 降低更新表的速度, 增删改都系要对索引进行维护
	
	# 小表使用全表扫描更快,中大表才使用索引,超级大表索引基本无效

	# 索引分类
		* 从数据结构上来说分为 
			1. BTree 索引(B+Tree)
			2. Hash 索引
			3. Full Index 索引
			4. RTree 索引

		* 实现上说,分成 2 种(根据数据的物理顺序与键值的逻辑(索引)顺序关系
			1. 聚集索引
			
			2. 辅助索引(也叫二级索引或者非聚集索引)
	

		* 功能(应用)上说上说,分成 6 种

			1. 普通索引
				* 最基本的索引,没有任何约束

			2. 唯一索引
				* 与普通索引类似,但具有唯一性约束
				* 唯一索引可以为空,但是空值只能有一个

			3. 主键索引
				* 特殊的唯一索引,不允许有空值

			4. 复合索引
				* 将多个列组合在一起创建索引,可以覆盖多个列, 专门用于组合搜索, 其效率大于索引合并

			5. 外键索引
				* 只有InnoDB类型的表才可以使用外键索引,保证数据的一致性,完整性和实现级联操作

			6. 全文索引
				* MySQL 自带的全文索引只能用于 InnoDB、MyISAM ,并且只能对英文进行全文检索
				* 全文检索一般使用全文索引引擎(ES, Solr)来完成
	
	# B+树索引
		* B树,是一个多路平衡查找树,相较于普通的二叉树,不会发生极度不平衡的状况,同时也是多路的
		* 他会将数据也保存在非页子节点
		* B+ 树的高度在 2-4 层, 由 MySql 在运行时, 根节点是常驻内存的, 因此每次查找只需要大约 2 -3 次 IO
		* 可以说, B+ 树的设计, 就是根据机械磁盘的特性来进行设计的

		* 如果B+树只有1层, 也就是只有1个用于存放用户记录的节点, 最多能存放1000条记录
		* 如果B+树有2层, 最多能存放1000×1000=1000000条记录
		* 如果B+树有3层, 最多能存放1000×1000×1000=1000000000条记录
		* 如果B+树有4层, 最多能存放1000×1000×1000×1000=1000000000000条记录
		* 表里需要存放1000000000000条记录么?所以一般情况下, 用到的B+树都不会超过4层
		* 通过主键去查找某条记录最多只需要做4个页面内的查找, 又因为在每个页面内有所谓的Page Directory, 所以在页面内也可以通过二分法实现快速定位记录
		
		* B+树中每层节点(数据页)都是按照索引列值从小到大的顺序排序而组成了双向链表
		* 每个页内的记录(不论是用户记录还是目录项记录)都是按照索引列的值从小到大的顺序而形成了一个单链表

		* MySql 的主键不能太大, 如果使用 UUID 这种,将会浪费 B+ 树的非叶子节点
		* MySql 的主键最好是自增的, 如果使用 UUID 这种, 每次插入都会调整 B+树, 从而导致页分裂, 严重影响性能


	

	# 为什么不使用红黑树(平衡二叉树)
		* 搜索性能不足, 在树结构中数据的深度决定着它搜索时的io次数
		* 节点数据内容太少, 每一个磁盘块(节点/页), 保存的关键字数量太少了
			* 没有很好的利用操作系统和磁盘的数据交换特性和磁盘预读能力(空间局部性原理)
			* 磁盘和操作系统的一次io交互, 一次是一个页(单位是页), 一页是4kb

		* 红黑树每个节点只能村存储一个数据, 需要一次性加载到内存进行比较. 通俗理解就是, 一次与磁盘的交互, 只能进行一次比较
		* 而B+Tree, 一次与磁盘的交互, 可以进行N次比较, 因为BTree一个节点, 有N多数据, 可以一次性加载到内存,  在内存中进行N次比较效率比多次IO磁盘后进行比较要快


	# 不同引擎的索引文件存储
		*  MyIsam
			.frm	表约束
			.MYD	数据
			.MYI	索引

			* 索引和数据分开
			* 索引的数据, 就是表数据的硬盘地址指针

		*  InnoDB
			.frm	表约束
			.ibd	索引

			* 数据即索引


	# 聚集索引
		* 聚集索引, 就是数据和索引存储在一起
		* Innodb表, 只会有一个聚集索引
		* 默认拿主键id作为索引
		* 如果主键id不存在, 那么会使用非空的唯一索引作为聚集索引
		* 如果没主键索引, 也没非空的唯一索引, 那么会自己维护一个id来作为聚集索引(隐式的 6 字节的索引)

		* 页内的记录是按照主键的大小顺序排成一个单向链表
		* 各个存放用户记录的页也是根据页中记录的主键大小顺序排成一个双向链表
		* 各个存放目录项的页也是根据页中记录的主键大小顺序排成一个双向链表
		
		* B+树的叶子节点存储的是完整的用户记录

		

	# 非聚集索引/二级索引/辅助索引
		* 它的任务就是指向聚集索引
		* 它存储的数据是聚集索引的索引值(主键值)

		* 获取到最终的数据, 仍然需要到聚簇索引中再查一遍，这个过程也被称为回表


	# 联合索引
		* 每条索引记录, 都是由联合索引的列值
		* 它存储的数据是聚集索引的索引值(主键值)
		* 还是需要回表, 才能检索到真正的数据

		* 存在多个列的联合主键, 从左往右依次比较大小, 直到第一个比出结果

	
	
------------------------
B+树索引适用的条件		|
------------------------
	# SQL
		CREATE TABLE person_info(
			name VARCHAR(100) NOT NULL,
			birthday DATE NOT NULL,
			phone_number CHAR(11) NOT NULL,
			country varchar(100) NOT NULL,
			KEY idx_name_age_birthday (name, birthday, phone_number)
		);

	# 全值匹配
		* 搜索条件中的列的顺序必须和索引列的定义顺序一致
		* 如果搜索条件中的列的顺序和索引列的顺序不一致, 由于B+树中的数据页和记录是先按第一列的值进行排序的, 不能直接使用二分法快速定位记录, 所以只能扫描所有的记录页
			SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';

	# 匹配左边的列
		* 在我们的搜索语句中也可以不用包含全部联合索引中的列, 只包含最左边的就行
			SELECT * FROM person_info WHERE name = 'Ashburn';

		* 或者包含多个最左边的列
			SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
		
		* 如果第一个条件不是索引列的第一个, 那么不会走索引
			SELECT * FROM person_info WHERE birthday = '1990-09-27';
	
	# 匹配列前缀
		* 对于字符串类型的索引列来说, 没必要对该列的值进行精确匹配, 只匹配它的前缀也是可以的, 因为前缀本身就已经是排好序的
			SELECT * FROM person_info WHERE name LIKE 'As%';

		* 如果只给出后缀或者中间的某个字符串, 就无法通过二分法来快速定位记录位置了, 因为字符串中间有指定的字符串并没有排好序, 所以只能全表扫描了
			SELECT * FROM person_info WHERE name LIKE '%As%';
			SELECT * FROM person_info WHERE name LIKE 'As%';
		
	# 匹配范围值
		* 所有记录都是按照索引列的值从小到大的顺序排好序的, 所以这极大的方便我们查找索引列的值在某个范围内的记录
			SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';

		* 如果对多个列同时进行范围查找的话, 只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引
			SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';

			- 只有name值相同的前提下才能用birthday列的值进行排序, 但是name不一定是相同的
			- 就算是name相同, 但是通过name进行范围查找的结果并不是按照birthday列进行排序的, 所以在搜索条件中继续以birthday列进行查找时是用不到B+树索引的
			- 所以 birthday 不走索引
	
	# 精确匹配某一列并范围匹配另外一列
		* 同一个联合索引来说, 虽然对多个列都进行范围查找时只能用到最左边那个索引列, 但是如果左边的列是精确查找, 则右边的列可以进行范围查找
			SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';

			- name是精确查找, 肯定是可以走索引
			- 条件查找后得到的结果的name值都是相同的, 它们本身是先按照 name 排序, 再按照 birthday 排序, 所以 name 相同的记录, birthday 是有序的, 它的检索可以走索引
			- birthday 条件后得到的记录结果可能不同, 所以后面个字段 phone_number 不能走索引
	
	# 用于排序
		* 查询语句需要对查询出来的记录按照某种规则进行排序,
		* 对于不适用B+树索引进行排序的情况只能把记录都加载到内存中, 再用一些排序算法, 比如快速排序, 归并排序等等在内存中对这些记录进行排序, 然后再把排好序的结果集返回到客户端
		
		* 如果ORDER BY子句里使用到了索引列, 就有可能省去在内存中排序的步骤
			SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;

			- 排序的字段, 跟联合索引定义的一摸一样, 索引本身是定义好顺序的, 所以这个直接提取数据就完事儿
		
		* 同样的, 匹配索引左边的列的形式可以使用部分的B+树索引
			SELECT * FROM person_info ORDER BY name, phone_number LIMIT 10;

			- name 会使用到索引, 在内存只用对 phone_number 进行排序就好
	
	# 不可以使用索引进行排序的几种情况
		* ASC, DESC混用
			- 对于使用联合索引进行排序的场景, 要求各个排序列的排序顺序是一致的, 也就是要么各个列都是ASC规则排序, 要么都是DESC规则排序
				SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10;

				- 先从索引的最左边确定name列最小的值, 然后找到name列等于该值的所有记录, 然后从name列等于该值的最右边的那条记录开始往左找10条记录
				- 如果name列等于最小的值的记录不足10条, 再继续往右找name值第二小的记录, 重复上边过程, 直到找到10条记录为止

		* WHERE子句中出现非排序使用到的索引列
			- WHERE子句中出现了非排序使用到的索引列, 那么排序依然是使用不到索引
				SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;
			
				- 先根据 country 进行过滤, 这个是没法走索引的
	
		* 排序列包含非同一个索引的列
			- 排序的多个列不是一个索引里的, 这种情况也不能使用索引进行排序
				SELECT * FROM person_info ORDER BY name, country LIMIT 10;

				- name和country并不属于一个联合索引中的列, 所以无法使用索引进行排序
		
		* 排序列使用了复杂的表达式
			- 要想使用索引进行排序操作, 必须保证索引列是以单独列的形式出现, 而不是修饰过的形式
				SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;

				- 使用了UPPER函数修饰过的列就不是单独的列, 这样就无法使用索引进行排序

		
	# 用于分组
		* 方便统计表中的一些信息, 会把表中的记录按照某些列进行分组
			SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number

			- 如果有索引的话, 恰巧这个分组顺序又和的B+树中的索引列的顺序是一致的
			- 而B+树索引又是按照索引列排好序的, 这正好, 所以可以直接使用B+树索引进行分组
		
		* 果没有索引的话, 这个分组过程全部需要在内存里实现
		* 和使用B+树索引进行排序是一个道理, 分组列的顺序也需要和索引列的顺序一致, 也可以只使用索引列中左边的列进行分组
	

------------------------
如何挑选索引			|
------------------------
	# 只为用于搜索, 排序或分组的列创建索引
		* 只为出现在WHERE子句中的列, 连接子句中的连接列, 或者出现在ORDER BY或GROUP BY子句中的列创建索引
		* 普通查询列表中的列就不要创建
	
	# 考虑列的基数
		* 列的基数指的是某一列中不重复数据的个数
		* 在记录行数一定的情况下, 列的基数越大, 该列中的值越分散, 列的基数越小, 该列中的值越集中
		* 列的基数指标非常重要, 直接影响是否能有效的利用索引
			- 假设某个列的基数为1, 也就是所有记录在该列中的值都一样
			- 那为该列建立索引是没有用的, 因为所有值都一样就无法排序, 无法进行二分法查找了
		
		* 最好为那些列的基数大的列建立索引, 为基数太小列的建立索引效果可能不好
	
	# 索引列的类型尽量小
		* 定义表结构的时候要显式的指定列的类型
		* 数据类型越小, 在查询时进行的比较操作越快
		* 数据类型越小, 索引占用的存储空间就越少, 在一个数据页内就可以放下更多的记录, 从而减少磁盘I/O带来的性能损耗,
		* 也就意味着可以把更多的数据页缓存在内存中, 从而加快读写效率

		* 对于表的主键来说更加适用, 因为不仅是聚簇索引中会存储主键值, 其他所有的二级索引的叶子节点处都会存储一份记录的主键值
		* 如果主键适用更小的数据类型, 也就意味着节省更多的存储空间
	
	# 索引字符串值的前缀
		* 一个字符串其实是由若干个字符组成, 如果在MySQL中适用utf8字符集去存储字符串的话, 编码一个字符需要占用1~3个字节
		* 假设字符串很长, 那存储一个字符串就需要占用很大的存储空间, 在需要为这个字符串列建立索引时, 那就意味着在对应的B+树中有这么两个问题
			1. B+树索引中的记录需要把该列的完整字符串存储起来, 而且字符串越长, 在索引中占用的存储空间越大
			2. 如果B+树索引中索引列存储的字符串很长, 那在做字符串比较时会占用更多的时间
		
		* 索引的设计者提出了个方案 --- 只对字符串的前几个字符进行索引
			- 通过字符串的前几个字符已经能大概排序字符串了, 剩下不能排序的可以通过遍历进行查找
			- 这样只在B+树中存储字符串的前几个字符的编码, 既节约空间, 又减少了字符串的比较时间, 还大概能解决排序的问题
		
		* 在建表语句中只对某列的前10个字符进行索引可以这么写:
			CREATE TABLE person_info(
				name VARCHAR(100) NOT NULL,
				birthday DATE NOT NULL,
				phone_number CHAR(11) NOT NULL,
				country varchar(100) NOT NULL,
				// name(10), 仅仅对前10个字符进行索引
				KEY idx_name_age_birthday (name(10), birthday, phone_number)
			);   
		
			* 如果使用了索引列前缀, 那么在使用该字段进行排序的时候, 无法走索引
				SELECT * FROM person_info ORDER BY name LIMIT 10;

				* 二级索引中不包含完整的name列信息, 所以无法对前十个字符相同, 后边的字符不同的记录进行排序
				* 也就是使用索引列前缀的方式无法支持使用索引排序
				
		
	# 尽量使用联合索引
		* 搜索条件中有多个列的话, 最好为这些列建立一个联合索引,  而不是分别为每个列建立一个索引(因为每建一个索引都会维护一棵B+树)
	
	# 让索引列在比较表达式中单独出现
		* 如果索引列在比较表达式中不是以单独列的形式出现, 而是以某个表达式, 或者函数调用形式出现的话, 不会走索取
		* 例如:my_col 是一个索引列
			WHERE my_col * 2 < 4
				* my_col列并不是以单独列的形式出现的, 而是以my_col * 2这样的表达式的形式出现的
				* 存储引擎会依次遍历所有的记录, 计算这个表达式的值是不是小于4

			WHERE my_col < 4/2
				* my_col列并是以单独列的形式出现的, 这样的情况可以直接使用B+树索引
	
	# 主键插入顺序
		* InnoDB存储引擎的表来说, 在没有显式的创建索引时, 表中的数据实际上都是存储在聚簇索引的叶子节点的
		* 而记录又是存储在数据页中的, 数据页和记录又是按照记录主键值从小到大的顺序进行排序,
		* 如果中途插入一个不大不小的主键值, 就会产生页面分裂和记录移位(树的子平衡)
		
		* 意味着:性能损耗, 所以如果想尽量避免这样无谓的性能损耗, 最好让插入的记录的主键值依次递增, 这样就不会发生这样的性能损耗了
		* 所以建议:让主键具有AUTO_INCREMENT, 让存储引擎自己为表生成主键, 而不是手动插入
	
	# 冗余和重复索引
		* 有时候会有意或者无意的就对同一个列创建了多个索引
		* 维护这个索引只会增加维护的成本, 并不会对搜索有什么好处
	
	# 覆盖索引
		* 最好在查询列表(结果集字段)里只包含索引列
			SELECT * FROM person_info WHERE name = 'Ashburn';

			- 因为是检索所有的记录, 所以联合检索出结果后, 还得去执行回表, 检索其他的数据记录
		
		* 如果仅仅检索联合查询的结果, 那么就不必执行回表操作了
		* 省去了回表操作带来的性能损耗, 把这种只需要用到索引的查询方式称为索引覆盖

		* 如果业务需要查询出索引以外的列, 那还是以保证业务需求为重
		* 但是很不鼓励用 * 号作为查询列表, 最好把我们需要查询的列依次标明
	


			



		
		
	

