----------------------------
锁							|
----------------------------
	# 参考
		https://mp.weixin.qq.com/s/V9nuZ-TNSI_avMVbCd1T7Q
		
	# 并发事务访问相同记录的情况大致可以划分为3种
		读 - 读
			* 读不会有啥问题
		
		写 - 写
			* 在这种情况下会发生脏写的问题, 任何一种隔离级别都不允许这种问题的发生
			* 多个未提交事务相继对一条记录做改动时, 需要让它们排队执行
			* 这个排队的过程其实是通过锁来实现的
		
		读-写/写-读
			* 这种情况下可能发生脏读, 不可重复读, 幻读的问题
			* 解决这些问题有两种办法
				1, 读操作使用MVCC,写操作加锁(事务笔记已经说了),读写不冲突, 性能比较高
				2, 读写, 都加锁, 读写都是需要排队, 性能比较差
					* 一个事务在写记录的时候就给这条记录加锁, 那么其他事务就无法继续读取该记录了, 所以也就不会有脏读问题的产生了
					* 一个事务读取记录时就给该记录加锁, 那么另一个事务就无法修改该记录, 自然也不会发生不可重复读了
					* 当前事务在第一次读取记录时那些幻影记录并不存在, 所以读取的时候加锁就有点尴尬 --―― 因为你并不知道给谁加锁(但是可以解决)
		
	# 锁
		* 锁其实是一个内存中的结构, 在事务执行前本来是没有锁的, 也就是说一开始是没有锁结构和记录进行关联的
		* 当一个事务想对这条记录做改动时, 首先会看看内存中有没有与这条记录关联的锁结构, 当没有的时候就会在内存中生成一个锁结构与之关联
		* 一个锁里面有很多的信息
			trx信息
				* 代表这个锁结构是哪个事务生成的
			is_waiting
				* 代表当前事务是否在等待
				* is_waiting属性如果是false,我们把这个场景就称之为获取锁成功, 或者加锁成功, 然后就可以继续执行操作了
		
		* 一个锁的过程(update)
			1. A事务操作数据, 发现该记录还没锁的信息, 于是设置了一个关联:is_waiting=false, 获取到了锁, 开始执行

			2. B事务操作数据, 发现存在了锁信息, 于是也设置了一个关联:is_waiting=true,当前事务需要等待(获取锁失败, 或者加锁失败, 或者没有成功的获取到锁

			3. A线程事务提交之前, 会把生成的锁结构释放掉, 然后看看还有没有别的事务在等待获取锁,
				* 发现了事务B还在等待获取锁, 所以把事务B对应的锁结构的is_waiting属性设置为false
				* 然后把该事务对应的线程唤醒, 让它继续执行, 此时事务B就算获取到锁了

----------------------------
一致性读(Consistent Reads)  |
----------------------------
	# 事务利用MVCC进行的读取操作称之为一致性读, 或者一致性无锁读, 有的地方也称之为快照读
	# 所有普通的SELECT语句(plain SELECT)在READ COMMITTED, REPEATABLE READ隔离级别下都算是一致性读
	# 一致性读并不会对表中的任何记录做加锁操作, 其他事务可以自由的对表中的记录做改动

----------------------------
锁定读 (Locking Reads)	和写|
----------------------------
	# 共享锁, 英文名: Shared Locks, 简称S锁
		* 在事务要读取一条记录时, 需要先获取该记录的S锁
		* 共享锁语句
			SELECT ... LOCK IN SHARE MODE;

		* 当前事务执行了该语句, 那么它会为读取到的记录加S锁, 这样允许别的事务继续获取这些记录的S锁
		* 比方说别的事务也使用SELECT ... LOCK IN SHARE MODE语句来读取这些记录

		* 但是不能获取这些记录的X锁(比方说使用SELECT ... FOR UPDATE语句来读取这些记录, 或者直接修改这些记录)
		* 如果别的事务想要获取这些记录的X锁, 那么它们会阻塞, 直到当前事务提交之后将这些记录上的S锁释放掉
		
	# 独占锁, 英文名:Exclusive Locks, 简称X锁(也称为排他锁)
		* 在事务要改动一条记录时, 需要先获取该记录的X锁
		* 独占锁语句
			SELECT ... FOR UPDATE;
		
		* 如果当前事务执行了该语句, 那么它会为读取到的记录加X锁, 这样既不允许别的事务获取这些记录的S锁
		* 比方说别的事务使用SELECT ... LOCK IN SHARE MODE语句来读取这些记录, 更不允许获取这些记录的X锁
		* 如果别的事务想要获取这些记录的S锁或者X锁, 那么它们会阻塞, 直到当前事务提交之后将这些记录上的X锁释放掉

		
	# 锁的兼容
		兼容性	X		S
		X		不兼容	不兼容
		S		不兼容	兼容

		* 只有 s s 是兼容的
	
	# 写操作
		DELETE
			* DELETE操作的过程其实是先在B+树中定位到这条记录的位置, 然后获取一下这条记录的X锁
			* 然后再执行delete mark操作, 我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读

		UPDATE
			* 分为三种情况
				1. 如果'未修改该记录的键值', 并且'被更新的列占用的存储空间在修改前后未发生变化',
					* 则先在B+树中定位到这条记录的位置, 然后再获取一下记录的X锁, 最后在原记录的位置进行修改操作
					* 其实也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读
				
				2. 如果'未修改该记录的键值'并且'至少有一个被更新的列占用的存储空间在修改前后发生变化',
					* 则先在B+树中定位到这条记录的位置, 然后获取一下记录的X锁, 将该记录彻底删除掉(就是把记录彻底移入垃圾链表)
					* 最后再插入一条新记录, 这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读
					* 新插入的记录由INSERT操作提供的隐式锁进行保护
				
				3. '如果修改了该记录的键值'
					* 则相当于在原记录上做DELETE操作之后再来一次INSERT操作
					* 加锁操作就需要按照DELETE和INSERT的规则进行了

		INSERT
			* 新插入一条记录的操作一般并不加锁,但在一些特殊情况下INSERT操作也是会获取锁的
			* InnoDB的通过一种称之为隐式锁的东东来保护这条新插入的记录在本事务提交前不被别的事务访问

------------------------
多粒度锁				|
------------------------
	# 事务也可以在表级别进行加锁
		* 自然就被称之为表级锁或者表锁
		* 对一个表加锁影响整个表中的记录, 这个锁的粒度比较粗
	
	# 事务也可以在行级别进行加锁
		* 对一条记录加锁影响的也只是这条记录而已, 我们就说这个锁的粒度比较细
	
	# 给表加S锁
		别的事务可以继续获得该表的S锁
		别的事务可以继续获得该表中的某些记录的S锁
		别的事务不可以继续获得该表的X锁
		别的事务不可以继续获得该表中的某些记录的X锁

	# 给表加X锁
		别的事务不可以继续获得该表的S锁
		别的事务不可以继续获得该表中的某些记录的S锁
		别的事务不可以继续获得该表的X锁
		别的事务不可以继续获得该表中的某些记录的X锁
	

	# 意向锁(Intention Locks)
		* 我们在对表上锁时,需要确定表中的行是否被上锁, 如果使用遍历, 效率很低
		* 于是设计了意向锁
	
		* 意向共享锁,英文名：Intention Shared Lock, 简称IS锁
			* 当事务准备在某条记录上加S锁时, 需要先在表级别加一个IS锁

		* 意向独占锁,英文名: Intention Exclusive Lock, 简称IX锁
			* 当事务准备在某条记录上加X锁时, 需要先在表级别加一个IX锁
		
		* IS, IX锁是表级锁, 它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁, 以避免用遍历的方式来查看表中有没有上锁的记录
		* 也就是说其实IS锁和IX锁是兼容的, IX锁和IX锁是兼容的
	
	# 兼容性
		兼容性	X		IX		S		IS
		X		不兼容	不兼容	不兼容	不兼容
		IX		不兼容	兼容	不兼容	兼容
		S		不兼容	不兼容	兼容	兼容
		IS		不兼容	兼容	兼容	兼容

------------------------
表锁					|
------------------------
	# 不同存储引擎对锁的支持也是不一样的, 这里仅仅说 InnoDB的锁

	# InnoDB存储引擎既支持表锁, 也支持行锁
		* 表锁实现简单, 占用资源较少, 不过粒度很粗, 性能比较差
		* 行锁粒度更细, 可以实现更精准的并发控制 
	
	# 表级别的 S锁, X锁
		* 在对某个表执行SELECT, INSERT, DELETE, UPDATE语句时, InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。

		* 在对某个表执行一些诸如ALTER, TABLE, DROP TABLE这类的DDL语句时, 其他事务对这个表并发执行诸如SELECT, INSERT, DELETE, UPDATE的语句会发生阻塞
		* 同理, 某个事务中对某个表执行SELECT, INSERT, DELETE, UPDATE语句时, 在其他会话中对这个表执行DDL语句也会发生阻塞

		* 这个过程其实是通过在server层使用一种称之为元数据锁(英文名:Metadata Locks, 简称MDL)来实现的
			* 一般情况下也不会使用InnoDB存储引擎自己提供的表级别的S锁和X锁
		
		* 手动获取InnoDB存储引擎提供的表的S锁或者X锁可以这么写
			LOCK TABLES [表名] READ		InnoDB存储引擎会对表t加表级别的S锁
			LOCK TABLES [表名] WRITE	InnoDB存储引擎会对表t加表级别的X锁

		* 尽量避免在使用InnoDB存储引擎的表上使用LOCK TABLES这样的手动锁表语句, 它们并不会提供什么额外的保护, 只是会降低并发能力而已
		* 关于表级别的S锁和X锁了解一下就罢了
	
	# 表级别的 IS锁, IX锁
		* 对使用InnoDB存储引擎的表的某些记录加S锁之前, 那就需要先在表级别加一个IS锁
		* 对使用InnoDB存储引擎的表的某些记录加X锁之前, 那就需要先在表级别加一个IX锁

		* IS锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录, 以避免用遍历的方式来查看表中有没有上锁的记录
	
	# 表级别的AUTO-INC锁
		* 可以为表的某个列添加AUTO_INCREMENT属性, 之后在插入记录时, 可以不指定该列的值, 系统会自动为它赋上递增的值
		* 实现这种自动给AUTO_INCREMENT修饰的列递增赋值的原理主要是两个
			1. 采用AUTO-INC锁
				* 也就是在执行插入语句时就在表级别加一个AUTO-INC锁
				* 然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值, 在该语句执行结束后, 再把AUTO-INC锁释放掉
				* 这样一个事务在持有AUTO-INC锁的过程中, 其他事务的插入语句都要被阻塞, 可以保证一个语句中分配的递增值是连续的

				* AUTO-INC锁的作用范围只是单个插入语句, 插入语句执行完成后, 这个锁就被释放了, 跟其他锁在事务结束时释放是不一样的

				* 锁住整个过程, 获取自增值, 插入

			
			2. 采用轻量级的锁
				* 在为插入语句生成AUTO_INCREMENT修饰的列的值时获取一下这个轻量级锁
				* 然后生成本次插入语句需要用到的AUTO_INCREMENT列的值之后, 就把该轻量级锁释放掉, 并不需要等到整个插入语句执行完才释放锁
				
				* 不会锁住整个的插入过程, 只是锁住获取自增值的过程


			
		* 如果插入语句在执行前不可以确定具体要插入多少条记录(无法预计即将插入记录的数量)
		* 比方说使用INSERT ... SELECT、REPLACE ... SELECT或者LOAD DATA这种插入语句
		* 一般是使用AUTO-INC锁为AUTO_INCREMENT修饰的列生成对应的值

		* 如果我们的插入语句在执行前就可以确定具体要插入多少条记录, 那么就可以采用轻量级锁
		
		* 使用参数控制使用哪个自增锁
			innodb_autoinc_lock_mode

			0	一律采用AUTO-INC锁
			1	两种方式混合使用(也就是在插入记录数量确定时采用轻量级锁, 不确定时使用AUTO-INC锁)
			2	一律采用轻量级锁
				* 可能会造成不同事务中的插入语句为AUTO_INCREMENT修饰的列生成的值是交叉的
				* 在有主从复制的场景中是不安全的
	

------------------------
行锁					|
------------------------
	# 行锁, 也称为记录锁, 顾名思义就是在记录上加的锁
		* 但是行锁是玩儿出花儿来的, 有很多名堂

	# Record Locks
		* 正经记录锁, LOCK_REC_NOT_GAP
		* 正经记录锁是有S锁和X锁之分的, 让分别称之为'S型正经记录锁'和'X型正经记录锁'
		
		* 当一个事务获取了一条记录的S型正经记录锁后, 其他事务也可以继续获取该记录的S型正经记录锁, 但不可以继续获取X型正经记录锁
		* 当一个事务获取了一条记录的X型正经记录锁后, 其他事务既不可以继续获取该记录的S型正经记录锁, 也不可以继续获取X型正经记录锁


	# Gap Locks
		* 间隙锁, LOCK_GAP
		* REPEATABLE READ隔离级别下是可以解决幻读问题的, 可以使用MVCC方案解决, 也可以采用加锁方案解决
		
		* 问题在于事务在第一次执行读取操作时, 幻影记录尚不存在, 无法给这些幻影记录加上正经记录锁
		* 间隙锁的存在, 就可以解决这些问题

		* 演示表
			+--+-----+
			|id|name |
			+--+-----+
			|1 |Kevin|
			+--+-----+
			|5 |Litch|
			+--+-----+
		
			* 如果为id=5的这行记录添加间隙锁, 意味着不允许别的事务在id值为5的记录前边的间隙插入新记录
			* 其实就是id列的值(1, 5)这个区间的新记录, 是不允许立即插入的, 会阻塞直到当前事务提交, Gap Locks 释放
		
		
			* gap锁只是不允许其他事务往这条记录前边的间隙插入新记录, 那对于最后一条记录之后的间隙是允许的
				* 2,3,4 无法插入, 但是 6, 7, 8..... 是可以插入成功

			* 数据页存在两条伪记录
				Infimum记录, 表示该页面中最小的记录
				Supremum记录, 表示该页面中最大的记录
			
			* 为了防止其他事务插入区间 (5, 无穷大)的新纪录, 可以给索引中的最后一条记录(本例为:5),所数据页的Supremum记录加上一个gap锁
		

		* 'gap锁的提出仅仅是为了防止插入幻影记录而提出的'
		* 虽然有共享gap锁和独占gap锁这样的说法, 但是它们起到的作用都是相同的
		* 对一条记录加了gap锁(不论是共享gap锁还是独占gap锁), 并不会限制其他事务对这条记录加正经记录锁或者继续加gap锁
	
	# Next-Key Locks
		* next-key锁, LOCK_ORDINARY
		* next-key锁的本质就是一个正经记录锁和一个gap锁的合体, 它既能保护该条记录, 又能阻止别的事务将新记录插入被保护记录前边的间隙
	
	# Insert Intention Locks
		* 插入意向锁, LOCK_INSERT_INTENTION
		* 个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁(next-key锁也包含gap锁)
		* 如果有的话，插入操作需要等待, 直到拥有gap锁的那个事务提交

		* InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构, 表明有事务想在某个间隙中插入新记录
		* 这就是插入意向锁

		* 执行的过程
			1. 事务1, 对id=5开启了 Gap 锁
			2. 事务2, 插入 id=4, 未能获取到插入意向锁, 阻塞
			3. 事务3, 插入 id=3, 未能获取到插入意向锁,阻塞
			4. 事务1, 提交, 释放 Gap 锁
			5. 事务2,3 获取到插入意向锁(is_waiting=false), 执行插入, 它们不会互相阻塞
		
		* 插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁
	

	# 隐式锁
		* 一个事务在执行INSERT操作时, 如果即将插入的间隙已经被其他事务加了gap锁, 那么本次INSERT操作会阻塞
		* 并且当前事务会在该间隙上加一个插入意向锁, 否则一般情况下INSERT操作是不加锁的

		* 问题: 一个事务首先插入了一条记录(此时并没有与该记录关联的锁结构)
			情况1
				* 然后另一个事务执行立即使用SELECT ... LOCK IN SHARE MODE语句读取这条事务, 也就是在要获取这条记录的S锁
				* 或者使用SELECT ... FOR UPDATE语句读取这条事务或者直接修改这条记录, 也就是要获取这条记录的X锁
				* 如果允许这种情况的发生，那么可能产生脏读问题
			
			情况2
				* 另一个事务立即修改这条记录, 也就是要获取这条记录的X锁
				* 如果允许这种情况的发生, 那么可能产生脏写问题
		
		* 解决
			情况1:
				* 对于聚簇索引记录来说, 有一个trx_id隐藏列, 该隐藏列记录着最后改动该记录的事务id
				* 如果在当前事务中新插入一条聚簇索引记录后, 该记录的trx_id隐藏列代表的的就是当前事务的事务id
				* 如果其他事务此时想对该记录添加S锁或者X锁时, 首先会看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务(未提交的/回滚的)
				
				* 如果是的话, 那么就帮助当前事务创建一个X锁(也就是为当前事务创建一个锁结构,is_waiting=false)
				* 然后自己进入等待状态(也就是为自己也创建一个锁结构, is_waiting=true)


			情况2:	
				* 二级索引记录, 本身并没有trx_id隐藏列, 但是在二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID属性
				* 该属性代表对该页面做改动的最大的事务id, 如果PAGE_MAX_TRX_ID属性值小于当前最小的活跃事务id
				* 那么说明对该页面做修改的事务都已经提交了, 否则就需要在页面中定位到对应的二级索引记录, 然后回表找到它对应的聚簇索引记录
				* 然后再重复情况1的做法



		* 一个事务对新插入的记录可以不显式的加锁(生成一个锁结构)
		* 但是由于事务id的存在, 相当于加了一个隐式锁

		* 别的事务在对这条记录加S锁或者X锁时, 由于隐式锁的存在, 会先帮助当前事务生成一个锁结构, 然后自己再生成一个锁结构后进入等待状态

	# 行锁的实现原理就是锁住聚集索引, 如果查询的时候, 没有正确地命中索引, MySql 优化器将会抛弃行锁, 使用表锁

	# 总结
		Record Locks
			* 锁定自己

		Gap Locks		
			* 锁定间隙, 不包含自己

		Next-Key Locks	
			* 锁定间隙, 以及自己

		Insert Intention Locks
			* 在gap锁阻塞的试试, 添加的意向锁

		隐式锁
			* 使用事务id的锁, 防止新插入的数据, 被其他事务加锁, 而导致脏读/脏写
		
	
------------------------
锁的内存结				|
------------------------
	# 一条记录加锁的本质就是在内存中创建一个锁结构与之关联
	# 一个事务对多条记录加锁, 如果需要对每条记录都创建一个锁, 是非常的可怕, 浪费资源的
	# 怎么把多个记录的锁, 放在同一个锁结构里面? 需要符合几个条件
		1, 在同一个事务中进行加锁操作
		2, 被加锁的记录在同一个页面中
		3, 加锁的类型是一样的
		4, 等待状态是一样的
	
	# 一个锁结构的结构
		锁事务信息
		索引信息
		表锁/行锁信息
			表锁:
				表信息,
				其他信息
			行锁:
				Space ID
				Page Number
				n_bit
					* 一条记录就对应着一个比特位, 一个页面中包含很多记录
					* 用不同的比特位来区分到底是哪一条记录加了锁,为此在行锁结构的末尾放置了一堆比特位,
					* 这个n_bits属性代表使用了多少比特
		type_mode
			* 锁的模式(lock_mode), 占用低4位, 可选的值如下
				LOCK_IS(十进制的0): 表示共享意向锁，也就是IS锁。
				LOCK_IX(十进制的1): 表示独占意向锁，也就是IX锁。
				LOCK_S(十进制的2): 表示共享锁，也就是S锁。
				LOCK_X(十进制的3): 表示独占锁，也就是X锁。
				LOCK_AUTO_INC(十进制的4): 表示AUTO-INC锁。

			* 锁的类型(lock_type), 占用第5～8位, 不过现阶段只有第5位和第6位被使用
				LOCK_TABLE(十进制的16), 也就是当第5个比特位置为1时, 表示表级锁
				LOCK_REC(十进制的32), 也就是当第6个比特位置为1时, 表示行级锁
			
			...
		
		其他信息
		一堆比特位